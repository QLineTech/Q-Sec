```
"high": ["architecture", "redesign", "major", "system-wide", "third-party"],
            "medium": ["configuration", "update", "modification", "component"],
            "low": ["setting", "minor", "documentation", "single-file"]
        }
        
        description = finding.get("description", "").lower()
        recommendation = finding.get("recommendation", "").lower()
        combined_text = f"{description} {recommendation}"
        
        # Ã‡aba seviyesini belirle
        for level, indicators in effort_indicators.items():
            if any(indicator in combined_text for indicator in indicators):
                return level
        
        return "medium"  # VarsayÄ±lan seviye

    def _analyze_cwe_coverage(self, results):
        """
        Common Weakness Enumeration (CWE) kapsamÄ±nÄ± analiz eder.
        Bulunan zafiyetleri CWE kategorileriyle eÅŸleÅŸtirir.
        """
        cwe_coverage = {
            "analyzed_weaknesses": [],
            "coverage_statistics": {
                "total_cwe_mapped": 0,
                "unique_cwe_categories": set(),
                "severity_distribution": {}
            },
            "top_weakness_categories": []
        }
        
        def map_to_cwe(item):
            if isinstance(item, dict):
                if "cwe_id" in item:
                    cwe_info = {
                        "cwe_id": item["cwe_id"],
                        "description": item.get("description", ""),
                        "severity": item.get("severity", ""),
                        "finding_count": 1
                    }
                    cwe_coverage["analyzed_weaknesses"].append(cwe_info)
                    cwe_coverage["coverage_statistics"]["unique_cwe_categories"].add(item["cwe_id"])
                    
                    severity = item.get("severity", "unknown").lower()
                    if severity not in cwe_coverage["coverage_statistics"]["severity_distribution"]:
                        cwe_coverage["coverage_statistics"]["severity_distribution"][severity] = 0
                    cwe_coverage["coverage_statistics"]["severity_distribution"][severity] += 1
                
                for value in item.values():
                    if isinstance(value, (dict, list)):
                        map_to_cwe(value)
            elif isinstance(item, list):
                for i in item:
                    map_to_cwe(i)
        
        map_to_cwe(results)
        
        # Ä°statistikleri gÃ¼ncelle
        cwe_coverage["coverage_statistics"]["total_cwe_mapped"] = len(cwe_coverage["analyzed_weaknesses"])
        cwe_coverage["coverage_statistics"]["unique_cwe_categories"] = len(cwe_coverage["coverage_statistics"]["unique_cwe_categories"])
        
        # En Ã§ok gÃ¶rÃ¼len zayÄ±flÄ±k kategorilerini belirle
        category_counts = {}
        for weakness in cwe_coverage["analyzed_weaknesses"]:
            cwe_id = weakness["cwe_id"]
            if cwe_id not in category_counts:
                category_counts[cwe_id] = {
                    "count": 0,
                    "description": weakness["description"],
                    "severity": weakness["severity"]
                }
            category_counts[cwe_id]["count"] += 1
        
        # En Ã§ok gÃ¶rÃ¼len kategorileri sÄ±rala
        sorted_categories = sorted(
            category_counts.items(),
            key=lambda x: x[1]["count"],
            reverse=True
        )
        
        cwe_coverage["top_weakness_categories"] = [
            {
                "cwe_id": cwe_id,
                "count": info["count"],
                "description": info["description"],
                "severity": info["severity"]
            }
            for cwe_id, info in sorted_categories[:5]  # Ä°lk 5 kategori
        ]
        
        return cwe_coverage

    def _analyze_compliance_status(self, results):
        """
        Genel uyumluluk durumunu analiz eder.
        FarklÄ± gÃ¼venlik standartlarÄ±na gÃ¶re uyumluluk seviyesini belirler.
        """
        compliance_status = {
            "overall_status": self._calculate_overall_compliance(results),
            "standard_specific_status": self._analyze_standard_compliance(results),
            "compliance_gaps": self._identify_compliance_gaps(results),
            "improvement_roadmap": self._create_compliance_roadmap(results)
        }
        
        return compliance_status

    def _calculate_overall_compliance(self, results):
        """
        Genel uyumluluk seviyesini hesaplar.
        TÃ¼m gÃ¼venlik standartlarÄ±nÄ± ve gereksinimleri deÄŸerlendirir.
        """
        compliance_scores = []
        
        # Her modÃ¼l iÃ§in uyumluluk puanÄ± hesapla
        for module_name, module_results in results.get("modules", {}).items():
            if isinstance(module_results, dict):
                score = self._calculate_module_compliance(module_results)
                compliance_scores.append(score)
        
        if not compliance_scores:
            return {
                "level": "Unknown",
                "score": 0,
                "details": "No compliance data available"
            }
        
        average_score = sum(compliance_scores) / len(compliance_scores)
        
        # Seviye belirleme
        if average_score >= 90:
            return {
                "level": "Full Compliance",
                "score": average_score,
                "details": "Meets or exceeds all major security requirements"
            }
        elif average_score >= 75:
            return {
                "level": "Substantial Compliance",
                "score": average_score,
                "details": "Meets most security requirements with minor gaps"
            }
        elif average_score >= 60:
            return {
                "level": "Partial Compliance",
                "score": average_score,
                "details": "Meets basic requirements but needs improvement"
            }
        else:
            return {
                "level": "Non-Compliant",
                "score": average_score,
                "details": "Significant compliance gaps exist"
            }

    def _identify_immediate_actions(self, results):
        """
        Acil eylem gerektiren sorunlarÄ± belirler.
        Kritik gÃ¼venlik aÃ§Ä±klarÄ± ve yÃ¼ksek riskli bulgular iÃ§in eylem planÄ± oluÅŸturur.
        """
        immediate_actions = []
        
        # Her modÃ¼lÃ¼ kontrol et
        for module_name, module_results in results.get("modules", {}).items():
            if isinstance(module_results, dict):
                # Kritik bulgularÄ± bul
                findings = module_results.get("findings", [])
                if isinstance(findings, list):
                    for finding in findings:
                        if finding.get("risk_level", "").lower() in ["critical", "high"]:
                            action = {
                                "title": finding.get("title", "Unnamed Finding"),
                                "risk_level": finding.get("risk_level", "Unknown"),
                                "module": module_name,
                                "impact": finding.get("impact", "Unknown impact"),
                                "mitigation": finding.get("mitigation", "No mitigation provided"),
                                "deadline": "Immediate",
                                "resources_needed": self._estimate_required_resources(finding)
                            }
                            immediate_actions.append(action)
        
        # Eylemleri Ã¶nceliklendir
        immediate_actions.sort(
            key=lambda x: (
                0 if x["risk_level"].lower() == "critical" else 1,
                1 if x["risk_level"].lower() == "high" else 2
            )
        )
        
        return immediate_actions

    def _estimate_required_resources(self, finding):
        """
        Bir bulgunun dÃ¼zeltilmesi iÃ§in gereken kaynaklarÄ± tahmin eder.
        Ä°nsan kaynaÄŸÄ±, zaman ve olasÄ± maliyeti deÄŸerlendirir.
        """
        resources = {
            "personnel": self._estimate_personnel_needs(finding),
            "time": self._estimate_time_requirement(finding),
            "cost": self._estimate_cost(finding),
            "dependencies": self._identify_dependencies(finding)
        }
        
        return resources

    def _estimate_personnel_needs(self, finding):
        """
        Gerekli personel kaynaklarÄ±nÄ± tahmin eder.
        """
        # Bulgunun karmaÅŸÄ±klÄ±ÄŸÄ±na gÃ¶re personel ihtiyacÄ±nÄ± belirle
        complexity = finding.get("complexity", "medium").lower()
        
        if complexity == "high":
            return {
                "security_engineer": 2,
                "developer": 2,
                "qa_engineer": 1,
                "system_admin": 1
            }
        elif complexity == "medium":
            return {
                "security_engineer": 1,
                "developer": 1,
                "qa_engineer": 1
            }
        else:
            return {
                "security_engineer": 1,
                "developer": 1
            }

    def _estimate_time_requirement(self, finding):
        """
        DÃ¼zeltme iÃ§in gereken sÃ¼reyi tahmin eder.
        """
        base_time = {
            "critical": 5,  # gÃ¼nler
            "high": 10,
            "medium": 15,
            "low": 20
        }
        
        risk_level = finding.get("risk_level", "low").lower()
        complexity_multiplier = {
            "high": 2.0,
            "medium": 1.5,
            "low": 1.0
        }
        
        complexity = finding.get("complexity", "medium").lower()
        
        estimated_days = base_time.get(risk_level, 20) * complexity_multiplier.get(complexity, 1.0)
        
        return {
            "estimated_days": estimated_days,
            "confidence_level": "medium",
            "factors": [
                "risk_level",
                "complexity",
                "dependencies"
            ]
        }

    def _estimate_cost(self, finding):
        """
        DÃ¼zeltme maliyetini tahmin eder.
        """
        # Personel maliyetleri (adam/gÃ¼n)
        daily_rates = {
            "security_engineer": 800,
            "developer": 600,
            "qa_engineer": 500,
            "system_admin": 550
        }
        
        personnel = self._estimate_personnel_needs(finding)
        time_estimate = self._estimate_time_requirement(finding)
        
        # Toplam personel maliyeti
        personnel_cost = sum(
            count * daily_rates[role] * time_estimate["estimated_days"]
            for role, count in personnel.items()
        )
        
        # Ek maliyetler
        additional_costs = {
            "tools_and_licenses": 0.15 * personnel_cost,  # Personel maliyetinin %15'i
            "training": 0.10 * personnel_cost,  # Personel maliyetinin %10'u
            "contingency": 0.20 * personnel_cost  # Personel maliyetinin %20'si
        }
        
        total_cost = personnel_cost + sum(additional_costs.values())
        
        return {
            "total_estimated_cost": total_cost,
            "breakdown": {
                "personnel_cost": personnel_cost,
                "additional_costs": additional_costs
            },
            "confidence_level": "medium",
            "notes": [
                "Costs are rough estimates",
                "Actual costs may vary based on implementation details",
                "Does not include long-term maintenance costs"
            ]
        }

    def _identify_dependencies(self, finding):
        """
        DÃ¼zeltme iÃ§in gereken baÄŸÄ±mlÄ±lÄ±klarÄ± belirler.
        """
        dependencies = {
            "systems": [],
            "third_party": [],
            "internal": []
        }
        
        # Sistem baÄŸÄ±mlÄ±lÄ±klarÄ±
        if "system" in finding.get("affected_components", []):
            dependencies["systems"].extend([
                "Operating System",
                "Security Controls",
                "Network Infrastructure"
            ])
        
        # ÃœÃ§Ã¼ncÃ¼ parti baÄŸÄ±mlÄ±lÄ±klar
        if "third_party" in finding.get("affected_components", []):
            dependencies["third_party"].extend([
                "External APIs",
                "Third-party Libraries",
                "Cloud Services"
            ])
        
        # Ä°Ã§ baÄŸÄ±mlÄ±lÄ±klar
        if "internal" in finding.get("affected_components", []):
            dependencies["internal"].extend([
                "Internal APIs",
                "Database Systems",
                "Authentication Services"
            ])
        
        return dependencies

    def generate_executive_dashboard(self, results):
        """
        Ãœst yÃ¶netim iÃ§in gÃ¶rsel dashboard oluÅŸturur.
        """
        dashboard = {
            "summary_metrics": self._calculate_summary_metrics(results),
            "risk_overview": self._create_risk_overview(results),
            "key_findings": self._summarize_key_findings(results),
            "improvement_metrics": self._calculate_improvement_metrics(results),
            "compliance_status": self._analyze_compliance_status(results),
            "recommendation_timeline": self._create_recommendation_timeline(results)
        }
        
        return dashboard

    def _calculate_improvement_metrics(self, results):
        """
        Ä°yileÅŸtirme metriklerini hesaplar ve trend analizi yapar.
        """
        metrics = {
            "security_score": self._calculate_security_score(results),
            "risk_reduction": self._calculate_risk_reduction(results),
            "implementation_progress": self._calculate_implementation_progress(results),
            "effectiveness_metrics": self._calculate_effectiveness_metrics(results)
        }
        
        return metrics

    def _create_recommendation_timeline(self, results):
        """
        Ã–neriler iÃ§in zaman Ã§izelgesi oluÅŸturur.
        """
        timeline = {
            "immediate": [],  # 0-24 saat
            "short_term": [], # 1-7 gÃ¼n
            "medium_term": [], # 1-4 hafta
            "long_term": []   # 1+ ay
        }
        
        # Her bulgu iÃ§in zaman planlamasÄ± yap
        for finding in results.get("findings", []):
            time_frame = self._determine_time_frame(finding)
            
            recommendation = {
                "title": finding.get("title", "Unnamed Finding"),
                "risk_level": finding.get("risk_level", "Unknown"),
                "estimated_effort": self._estimate_remediation_effort(finding),
                "dependencies": self._identify_dependencies(finding)
            }
            
            timeline[time_frame].append(recommendation)
        
        return timeline

    def _determine_time_frame(self, finding):
        """
        Bir bulgu iÃ§in uygun zaman Ã§erÃ§evesini belirler.
        """
        risk_level = finding.get("risk_level", "").lower()
        complexity = finding.get("complexity", "").lower()
        
        if risk_level == "critical":
            return "immediate"
        elif risk_level == "high":
            return "short_term"
        elif complexity == "high":
            return "long_term"
        else:
            return "medium_term"

if __name__ == "__main__":
    try:
        # API anahtarÄ±nÄ± gÃ¼venli bir ÅŸekilde al
        api_key = os.getenv("GROQ_API_KEY", "your-api-key")
        
        # Framework'Ã¼ baÅŸlat
        framework = AdvancedMobilePentestFramework(api_key)
        
        print("\nğŸš€ GeliÅŸmiÅŸ Mobil GÃ¼venlik Test Framework'Ã¼ BaÅŸlatÄ±ldÄ±")
        print("\nğŸ“± Test SenaryolarÄ± HazÄ±rlanÄ±yor...")

        # Test senaryolarÄ±nÄ± hazÄ±rla
        test_scenarios = [
            {
                "name": "Android Banking App Analysis",
                "target_info": {
                    "platform": "Android",
                    "os_version": "12",
                    "device_model": "Samsung Galaxy S21",
                    "app_package": "com.example.banking",
                    "app_version": "2.1.0",
                    "assessment_scope": ["malware", "owasp", "forensic"]
                },
                "expected_analysis_modules": ["malware", "owasp", "forensic"]
            },
            {
                "name": "iOS Cryptocurrency Wallet Security",
                "target_info": {
                    "platform": "iOS",
                    "os_version": "15.5",
                    "device_model": "iPhone 13 Pro",
                    "app_bundle": "com.example.cryptowallet",
                    "app_version": "1.5.2",
                    "assessment_scope": ["owasp", "forensic", "exploit"]
                },
                "expected_analysis_modules": ["owasp", "forensic", "exploit"]
            },
            {
                "name": "Mobile Game Security Assessment",
                "target_info": {
                    "platform": "Android",
                    "os_version": "11",
                    "device_model": "Google Pixel 6",
                    "app_package": "com.example.game",
                    "app_version": "3.0.1",
                    "assessment_scope": ["malware", "exploit"]
                },
                "expected_analysis_modules": ["malware", "exploit"]
            }
        ]

        # SonuÃ§larÄ± saklamak iÃ§in liste
        assessment_results = []

        # Her senaryo iÃ§in gÃ¼venlik deÄŸerlendirmesi yap
        for scenario in test_scenarios:
            print(f"\nğŸ” Test Senaryosu BaÅŸlatÄ±lÄ±yor: {scenario['name']}")
            print("=" * 50)
            
            try:
                # GÃ¼venlik deÄŸerlendirmesini Ã§alÄ±ÅŸtÄ±r
                results = framework.run_full_security_assessment(scenario['target_info'])
                
                # Executive dashboard oluÅŸtur
                dashboard = framework.generate_executive_dashboard(results)
                
                # SonuÃ§larÄ± kaydet
                assessment_results.append({
                    "scenario": scenario,
                    "results": results,
                    "dashboard": dashboard
                })
                
                # Ã–zet rapor gÃ¶ster
                print(f"\nâœ… DeÄŸerlendirme TamamlandÄ±: {scenario['name']}")
                print(f"ğŸ“Š Risk Seviyesi: {results.get('summary', {}).get('risk_level', 'Unknown')}")
                print(f"ğŸ¯ Bulunan Toplam Zafiyet: {len(results.get('findings', []))}")
                
                # Kritik bulgularÄ± gÃ¶ster
                critical_findings = [f for f in results.get('findings', []) 
                                  if f.get('risk_level', '').lower() == 'critical']
                if critical_findings:
                    print("\nâš ï¸ Kritik Bulgular:")
                    for finding in critical_findings:
                        print(f"- {finding.get('title', 'Unnamed Finding')}")
                
            except Exception as e:
                print(f"\nâŒ Hata: Senaryo Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken bir sorun oluÅŸtu: {str(e)}")
                continue

        # TÃ¼m sonuÃ§larÄ± dosyaya kaydet
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_dir = "security_assessments"
        os.makedirs(output_dir, exist_ok=True)
        
        for result in assessment_results:
            scenario_name = result['scenario']['name'].lower().replace(' ', '_')
            filename = f"{output_dir}/assessment_{scenario_name}_{timestamp}.json"
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=4, ensure_ascii=False)
            
            print(f"\nğŸ“ Rapor kaydedildi: {filename}")

        # Genel Ã¶zet gÃ¶ster
        print("\nğŸ“Š Genel DeÄŸerlendirme Ã–zeti")
        print("=" * 50)
        print(f"Toplam Test Edilen Senaryo: {len(assessment_results)}")
        
        # Risk daÄŸÄ±lÄ±mÄ±nÄ± hesapla
        risk_distribution = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0
        }
        
        total_findings = 0
        for result in assessment_results:
            findings = result['results'].get('findings', [])
            total_findings += len(findings)
            
            for finding in findings:
                risk_level = finding.get('risk_level', '').lower()
                if risk_level in risk_distribution:
                    risk_distribution[risk_level] += 1
        
        print(f"Toplam Bulunan Zafiyet: {total_findings}")
        print("\nRisk DaÄŸÄ±lÄ±mÄ±:")
        for level, count in risk_distribution.items():
            print(f"- {level.capitalize()}: {count}")
        
        # Ã–nerilen aksiyonlarÄ± gÃ¶ster
        print("\nğŸ¯ Ã–nerilen Ã–ncelikli Aksiyonlar:")
        for result in assessment_results:
            critical_findings = [f for f in result['results'].get('findings', [])
                               if f.get('risk_level', '').lower() in ['critical', 'high']]
            
            if critical_findings:
                print(f"\n{result['scenario']['name']}:")
                for finding in critical_findings[:3]:  # Ä°lk 3 kritik bulgu
                    print(f"- {finding.get('title', 'Unnamed Finding')}")
                    print(f"  Ã–neri: {finding.get('recommendation', 'No recommendation provided')}")

        print("\nâœ¨ GÃ¼venlik DeÄŸerlendirmesi TamamlandÄ±!")
        print("DetaylÄ± raporlar 'security_assessments' dizininde bulunabilir.")

    except KeyboardInterrupt:
        print("\n\nâš ï¸ Test sÃ¼reci kullanÄ±cÄ± tarafÄ±ndan durduruldu.")
        sys.exit(1)
    except Exception as e:
        print(f"\nâŒ Kritik hata: {str(e)}")
        sys.exit(1)
    def _summarize_key_findings(self, results):
        """
        Ã–nemli bulgularÄ± Ã¶zetler ve Ã¶ncelikleriyle birlikte listeler.
        Bu fonksiyon Ã¼st yÃ¶netimin hÄ±zlÄ±ca anlayabileceÄŸi bir Ã¶zet sunar.
        """
        summary = {
            "critical_findings": [],
            "high_priority_issues": [],
            "notable_patterns": [],
            "positive_aspects": []
        }
        
        # Kritik bulgularÄ± analiz et
        for module_name, module_results in results.get("modules", {}).items():
            if isinstance(module_results, dict):
                # Kritik gÃ¼venlik aÃ§Ä±klarÄ±nÄ± bul
                if "vulnerabilities" in module_results:
                    for vuln in module_results["vulnerabilities"]:
                        if vuln.get("risk_level", "").lower() == "critical":
                            summary["critical_findings"].append({
                                "title": vuln.get("title", "Unnamed Vulnerability"),
                                "impact": vuln.get("impact", "Unknown impact"),
                                "module": module_name,
                                "recommended_action": vuln.get("recommendation", "No specific recommendation")
                            })

                # YÃ¼ksek Ã¶ncelikli sorunlarÄ± belirle
                if "findings" in module_results:
                    for finding in module_results["findings"]:
                        if finding.get("priority", "").lower() == "high":
                            summary["high_priority_issues"].append({
                                "issue": finding.get("description", "Unnamed Issue"),
                                "context": finding.get("context", "No context provided"),
                                "module": module_name
                            })

        # Desenleri ve olumlu yÃ¶nleri analiz et
        self._analyze_patterns_and_positives(results, summary)
        
        return summary

    def _analyze_patterns_and_positives(self, results, summary):
        """
        GÃ¼venlik deÄŸerlendirmesindeki desenleri ve olumlu yÃ¶nleri analiz eder.
        Bu analiz, sistemdeki tekrar eden sorunlarÄ± ve iyi uygulamalarÄ± belirler.
        """
        patterns = {}
        positives = set()
        
        def analyze_item(item):
            if isinstance(item, dict):
                # Desenleri topla
                if "type" in item and "description" in item:
                    pattern_key = f"{item['type']}:{item.get('category', 'general')}"
                    if pattern_key not in patterns:
                        patterns[pattern_key] = {
                            "count": 0,
                            "examples": []
                        }
                    patterns[pattern_key]["count"] += 1
                    if len(patterns[pattern_key]["examples"]) < 3:  # En fazla 3 Ã¶rnek
                        patterns[pattern_key]["examples"].append(item["description"])

                # Olumlu yÃ¶nleri topla
                if item.get("assessment", "").lower() == "positive":
                    positives.add(item.get("description", ""))

                for value in item.values():
                    if isinstance(value, (dict, list)):
                        analyze_item(value)
            elif isinstance(item, list):
                for i in item:
                    analyze_item(i)

        # TÃ¼m sonuÃ§larÄ± analiz et
        analyze_item(results)

        # Ã–nemli desenleri ekle
        for pattern_key, pattern_data in patterns.items():
            if pattern_data["count"] >= 2:  # En az 2 kez tekrar eden desenler
                summary["notable_patterns"].append({
                    "pattern": pattern_key.split(":")[0],
                    "category": pattern_key.split(":")[1],
                    "occurrence_count": pattern_data["count"],
                    "examples": pattern_data["examples"]
                })

        # Olumlu yÃ¶nleri ekle
        summary["positive_aspects"] = list(positives)

    def _create_risk_overview(self, results):
        """
        Genel risk deÄŸerlendirmesi oluÅŸturur.
        Bu Ã¶zet, gÃ¼venlik durumunun Ã¼st dÃ¼zey bir gÃ¶rÃ¼nÃ¼mÃ¼nÃ¼ sunar.
        """
        return {
            "overall_risk_level": self.calculate_overall_risk(results),
            "risk_distribution": results.get("statistics", {}).get("risk_distribution", {}),
            "most_vulnerable_areas": self._identify_vulnerable_areas(results),
            "risk_trends": self._analyze_risk_trends(results),
            "comparative_analysis": self._create_comparative_analysis(results)
        }

    def _identify_vulnerable_areas(self, results):
        """
        En savunmasÄ±z alanlarÄ± belirler ve puanlar.
        Her alan iÃ§in risk skorunu ve etkisini hesaplar.
        """
        vulnerable_areas = {}
        
        def analyze_vulnerability(item, context=""):
            if isinstance(item, dict):
                if "risk_level" in item and "component" in item:
                    area = item["component"]
                    risk_score = self.risk_level_to_score(item["risk_level"])
                    
                    if area not in vulnerable_areas:
                        vulnerable_areas[area] = {
                            "total_score": 0,
                            "finding_count": 0,
                            "top_findings": []
                        }
                    
                    vulnerable_areas[area]["total_score"] += risk_score
                    vulnerable_areas[area]["finding_count"] += 1
                    
                    if risk_score >= 7:  # YÃ¼ksek riskli bulgular
                        finding_info = {
                            "description": item.get("description", "No description"),
                            "risk_level": item["risk_level"],
                            "context": context
                        }
                        vulnerable_areas[area]["top_findings"].append(finding_info)
                
                for key, value in item.items():
                    if isinstance(value, (dict, list)):
                        analyze_vulnerability(value, f"{context}/{key}" if context else key)
            elif isinstance(item, list):
                for i in item:
                    analyze_vulnerability(i, context)

        # TÃ¼m sonuÃ§larÄ± analiz et
        analyze_vulnerability(results)

        # AlanlarÄ± risk skorlarÄ±na gÃ¶re sÄ±rala
        sorted_areas = sorted(
            vulnerable_areas.items(),
            key=lambda x: x[1]["total_score"],
            reverse=True
        )

        return {
            area: data for area, data in sorted_areas[:5]  # En riskli 5 alan
        }

    def _analyze_risk_trends(self, results):
        """
        Risk trendlerini analiz eder ve zaman iÃ§indeki deÄŸiÅŸimleri belirler.
        GÃ¼venlik durumunun nasÄ±l evrildiÄŸini gÃ¶sterir.
        """
        trends = {
            "improving_areas": [],
            "worsening_areas": [],
            "stable_areas": [],
            "trend_factors": []
        }

        # Ã–nceki deÄŸerlendirmelerle karÅŸÄ±laÅŸtÄ±r
        if "previous_assessments" in results:
            for area, current_data in results.get("modules", {}).items():
                previous_data = results["previous_assessments"].get(area, {})
                
                if previous_data:
                    current_risk = self.calculate_area_risk(current_data)
                    previous_risk = self.calculate_area_risk(previous_data)
                    
                    change = current_risk - previous_risk
                    trend_info = {
                        "area": area,
                        "change": change,
                        "current_risk": current_risk,
                        "previous_risk": previous_risk,
                        "factors": self._identify_trend_factors(current_data, previous_data)
                    }
                    
                    if change < -1:  # Ä°yileÅŸme
                        trends["improving_areas"].append(trend_info)
                    elif change > 1:  # KÃ¶tÃ¼leÅŸme
                        trends["worsening_areas"].append(trend_info)
                    else:  # Stabil
                        trends["stable_areas"].append(trend_info)

        return trends

    def _create_comparative_analysis(self, results):
        """
        EndÃ¼stri standartlarÄ± ve benzer sistemlerle karÅŸÄ±laÅŸtÄ±rmalÄ± analiz yapar.
        Bu analiz, gÃ¼venlik durumunun gÃ¶receli konumunu belirler.
        """
        return {
            "industry_comparison": self._compare_with_industry_standards(results),
            "peer_comparison": self._compare_with_peer_systems(results),
            "benchmark_metrics": self._calculate_benchmark_metrics(results)
        }

    def _compare_with_industry_standards(self, results):
        """
        SonuÃ§larÄ± endÃ¼stri standartlarÄ±yla karÅŸÄ±laÅŸtÄ±rÄ±r.
        OWASP Mobile Top 10 ve CWE gibi standartlarÄ± referans alÄ±r.
        """
        standards_comparison = {
            "owasp_mobile_top_10": self._analyze_owasp_compliance(results),
            "common_weaknesses": self._analyze_cwe_coverage(results),
            "compliance_status": self._analyze_compliance_status(results)
        }
        
        return standards_comparison

    def _analyze_owasp_compliance(self, results):
        """
        OWASP Mobile Top 10 uyumluluÄŸunu analiz eder.
        Her kategori iÃ§in uyumluluk seviyesini hesaplar.
        """
        owasp_categories = {
            "M1": "Improper Platform Usage",
            "M2": "Insecure Data Storage",
            "M3": "Insecure Communication",
            "M4": "Insecure Authentication",
            "M5": "Insufficient Cryptography",
            "M6": "Insecure Authorization",
            "M7": "Client Code Quality",
            "M8": "Code Tampering",
            "M9": "Reverse Engineering",
            "M10": "Extraneous Functionality"
        }
        
        compliance_analysis = {}
        
        for category, description in owasp_categories.items():
            # Her kategori iÃ§in uyumluluk analizi yap
            findings = self._find_category_issues(results, category, description)
            
            compliance_analysis[category] = {
                "category_name": description,
                "findings_count": len(findings),
                "compliance_level": self._calculate_compliance_level(findings),
                "key_issues": [f["description"] for f in findings[:3]],  # En Ã¶nemli 3 sorun
                "recommendations": self._generate_category_recommendations(findings)
            }
        
        return compliance_analysis

    def _find_category_issues(self, results, category, description):
        """
        Belirli bir OWASP kategorisine ait sorunlarÄ± bulur.
        Metin analizi ve kategori eÅŸleÅŸtirmesi yapar.
        """
        category_findings = []
        
        def search_issues(item):
            if isinstance(item, dict):
                # Kategori etiketlerini kontrol et
                if item.get("owasp_category") == category:
                    category_findings.append(item)
                # AÃ§Ä±klama iÃ§inde arama yap
                elif any(keyword in str(item).lower() for keyword in description.lower().split()):
                    if "description" in item:
                        category_findings.append(item)
                
                for value in item.values():
                    if isinstance(value, (dict, list)):
                        search_issues(value)
            elif isinstance(item, list):
                for i in item:
                    search_issues(i)
        
        search_issues(results)
        return category_findings

    def _calculate_compliance_level(self, findings):
        """
        Bulgulara gÃ¶re uyumluluk seviyesini hesaplar.
        Risk seviyeleri ve bulgu sayÄ±sÄ±nÄ± dikkate alÄ±r.
        """
        if not findings:
            return {
                "level": "High",
                "score": 95,
                "description": "No significant issues found"
            }
        
        # Risk seviyelerine gÃ¶re puan dÃ¼ÅŸÃ¼r
        base_score = 100
        deductions = {
            "critical": 20,
            "high": 15,
            "medium": 10,
            "low": 5
        }
        
        for finding in findings:
            risk_level = finding.get("risk_level", "low").lower()
            base_score -= deductions.get(risk_level, 0)
        
        # PuanÄ± 0-100 aralÄ±ÄŸÄ±nda tut
        final_score = max(0, min(100, base_score))
        
        # Seviye belirleme
        if final_score >= 90:
            level = "High"
            description = "Excellent compliance with few minor issues"
        elif final_score >= 75:
            level = "Medium-High"
            description = "Good compliance with some areas for improvement"
        elif final_score >= 60:
            level = "Medium"
            description = "Moderate compliance with significant improvements needed"
        else:
            level = "Low"
            description = "Poor compliance with critical improvements required"
        
        return {
            "level": level,
            "score": final_score,
            "description": description
        }

    def _generate_category_recommendations(self, findings):
        """
        Kategori bazlÄ± Ã¶neriler oluÅŸturur.
        BulgularÄ±n Ã¶zelliklerine gÃ¶re Ã¶zel Ã¶neriler sunar.
        """
        recommendations = []
        
        # Risk seviyelerine gÃ¶re Ã¶nerileri grupla
        risk_groups = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": []
        }
        
        for finding in findings:
            risk_level = finding.get("risk_level", "low").lower()
            if risk_level in risk_groups:
                risk_groups[risk_level].append(finding)
        
        # Kritik ve yÃ¼ksek riskli bulgular iÃ§in detaylÄ± Ã¶neriler
        for risk_level in ["critical", "high"]:
            for finding in risk_groups[risk_level]:
                recommendations.append({
                    "priority": "Immediate",
                    "finding": finding.get("description", ""),
                    "action": finding.get("recommendation", ""),
                    "estimated_effort": self._estimate_remediation_effort(finding)
                })
        
        # Orta ve dÃ¼ÅŸÃ¼k riskli bulgular iÃ§in genel Ã¶neriler
        if risk_groups["medium"] or risk_groups["low"]:
            recommendations.append({
                "priority": "Planned",
                "finding": "Multiple medium/low risk issues",
                "action": "Implement security best practices and regular reviews",
                "estimated_effort": "Medium"
            })
        
        return recommendations

    def _estimate_remediation_effort(self, finding):
        """
        Bir bulgunun dÃ¼zeltilmesi iÃ§in gereken Ã§abayÄ± tahmin eder.
        Bulgunun karmaÅŸÄ±klÄ±ÄŸÄ± ve etki alanÄ±na gÃ¶re deÄŸerlendirme yapar.
        """
        effort_indicators = {
            "high": ["architecture", "redesign", "major    def generate_recommendations(self, results):
        """
        Analiz sonuÃ§larÄ±na gÃ¶re Ã¶neriler oluÅŸturur.
        Her risk seviyesi iÃ§in Ã¶zel Ã¶neriler ve eylem planlarÄ± oluÅŸturulur.
        """
        recommendations = {
            "immediate_actions": [],
            "short_term": [],
            "long_term": [],
            "best_practices": []
        }
        
        def extract_recommendations(item, category="best_practices"):
            if isinstance(item, dict):
                for key, value in item.items():
                    if "recommendation" in key.lower() or "solution" in key.lower():
                        if isinstance(value, str):
                            recommendations[category].append(value)
                        elif isinstance(value, list):
                            recommendations[category].extend(value)
                    elif isinstance(value, (dict, list)):
                        extract_recommendations(value, category)
            elif isinstance(item, list):
                for i in item:
                    extract_recommendations(i, category)
        
        # SonuÃ§larÄ± analiz et ve Ã¶nerileri kategorize et
        for key, value in results.items():
            if isinstance(value, dict) and "risk_level" in value:
                if value["risk_level"].lower() in ["critical", "high"]:
                    extract_recommendations(value, "immediate_actions")
                elif value["risk_level"].lower() == "medium":
                    extract_recommendations(value, "short_term")
                else:
                    extract_recommendations(value, "long_term")
            elif isinstance(value, (dict, list)):
                extract_recommendations(value)
        
        return recommendations

    def analyze_malware_sample(self, sample_data):
        """
        Mobil malware Ã¶rneÄŸinin detaylÄ± analizini gerÃ§ekleÅŸtirir.
        Static ve dinamik analiz tekniklerini kullanÄ±r.
        """
        try:
            # Malware analiz zincirini Ã§alÄ±ÅŸtÄ±r
            analysis_result = self.malware_chain.run(sample_data)
            
            # SonuÃ§larÄ± parse et
            parsed_result = self.parse_results(analysis_result)
            
            # Tehdit seviyesini belirle
            threat_level = self.determine_threat_level(parsed_result)
            
            # IOC'leri (Compromise GÃ¶stergeleri) Ã§Ä±kar
            iocs = self.extract_iocs(parsed_result)
            
            return {
                "analysis_result": parsed_result,
                "threat_level": threat_level,
                "iocs": iocs,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                "error": f"Malware analizi sÄ±rasÄ±nda hata: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }

    def determine_threat_level(self, analysis_result):
        """
        Malware analiz sonuÃ§larÄ±na gÃ¶re tehdit seviyesini belirler.
        Ã‡eÅŸitli faktÃ¶rleri deÄŸerlendirerek bir risk skoru hesaplar.
        """
        threat_indicators = {
            "high": [
                "root", "jailbreak", "banking", "ransomware", "keylogger",
                "remote_access", "data_exfiltration"
            ],
            "medium": [
                "adware", "excessive_permissions", "suspicious_api",
                "encrypted_payload", "dynamic_code"
            ],
            "low": [
                "aggressive_ads", "minimal_permissions", "open_source"
            ]
        }
        
        result_str = json.dumps(analysis_result).lower()
        
        # Tehdit gÃ¶stergelerini say
        threat_counts = {
            "high": sum(1 for ind in threat_indicators["high"] if ind in result_str),
            "medium": sum(1 for ind in threat_indicators["medium"] if ind in result_str),
            "low": sum(1 for ind in threat_indicators["low"] if ind in result_str)
        }
        
        # Tehdit seviyesini hesapla
        if threat_counts["high"] > 0:
            return "Critical"
        elif threat_counts["medium"] > 2:
            return "High"
        elif threat_counts["medium"] > 0 or threat_counts["low"] > 2:
            return "Medium"
        else:
            return "Low"

    def extract_iocs(self, analysis_result):
        """
        Analiz sonuÃ§larÄ±ndan IOC'leri (Compromise GÃ¶stergeleri) Ã§Ä±karÄ±r.
        URLs, IP adresleri, dosya hashleri gibi gÃ¶stergeleri toplar.
        """
        iocs = {
            "urls": [],
            "ips": [],
            "domains": [],
            "file_hashes": [],
            "package_names": [],
            "suspicious_patterns": []
        }
        
        def extract_from_item(item):
            if isinstance(item, dict):
                for key, value in item.items():
                    # URL ve domainleri bul
                    if isinstance(value, str):
                        if "http" in value.lower() or "https" in value.lower():
                            iocs["urls"].append(value)
                        elif "." in value and "/" not in value and " " not in value:
                            iocs["domains"].append(value)
                    
                    # Hash deÄŸerlerini bul
                    if "hash" in key.lower() and isinstance(value, str):
                        iocs["file_hashes"].append(value)
                    
                    # Paket isimlerini bul
                    if "package" in key.lower() and isinstance(value, str):
                        iocs["package_names"].append(value)
                    
                    if isinstance(value, (dict, list)):
                        extract_from_item(value)
            elif isinstance(item, list):
                for i in item:
                    extract_from_item(i)
        
        extract_from_item(analysis_result)
        return iocs

    def perform_forensic_analysis(self, device_data):
        """
        Mobil cihaz Ã¼zerinde detaylÄ± forensik analiz gerÃ§ekleÅŸtirir.
        Dosya sistemi, bellek ve iletiÅŸim verilerini analiz eder.
        """
        try:
            # Forensik analiz zincirini Ã§alÄ±ÅŸtÄ±r
            analysis_result = self.forensic_chain.run(device_data)
            
            # SonuÃ§larÄ± parse et
            parsed_result = self.parse_results(analysis_result)
            
            # Zaman Ã§izelgesi oluÅŸtur
            timeline = self.create_timeline(parsed_result)
            
            # Ã–nemli artifactlarÄ± Ã§Ä±kar
            artifacts = self.extract_artifacts(parsed_result)
            
            return {
                "analysis_result": parsed_result,
                "timeline": timeline,
                "artifacts": artifacts,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                "error": f"Forensik analiz sÄ±rasÄ±nda hata: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }

    def create_timeline(self, forensic_result):
        """
        Forensik analiz sonuÃ§larÄ±ndan detaylÄ± bir zaman Ã§izelgesi oluÅŸturur.
        Ã–nemli olaylarÄ± kronolojik sÄ±rayla dÃ¼zenler.
        """
        timeline_events = []
        
        def extract_events(item, context=""):
            if isinstance(item, dict):
                for key, value in item.items():
                    if "time" in key.lower() or "date" in key.lower():
                        if isinstance(value, str):
                            try:
                                event_time = datetime.fromisoformat(value)
                                timeline_events.append({
                                    "timestamp": event_time,
                                    "context": context,
                                    "event": key,
                                    "details": value
                                })
                            except ValueError:
                                pass
                    elif isinstance(value, (dict, list)):
                        extract_events(value, context + "/" + key if context else key)
            elif isinstance(item, list):
                for i in item:
                    extract_events(i, context)
        
        extract_events(forensic_result)
        
        # OlaylarÄ± zamana gÃ¶re sÄ±rala
        timeline_events.sort(key=lambda x: x["timestamp"])
        
        return timeline_events

    def extract_artifacts(self, forensic_result):
        """
        Forensik analiz sonuÃ§larÄ±ndan Ã¶nemli artifactlarÄ± Ã§Ä±karÄ±r.
        Dosyalar, loglar, iletiÅŸim verileri gibi Ã¶nemli bulgularÄ± toplar.
        """
        artifacts = {
            "files": [],
            "logs": [],
            "communications": [],
            "credentials": [],
            "applications": [],
            "system_data": []
        }
        
        def categorize_artifact(item, category, artifact):
            if category not in artifacts:
                artifacts[category] = []
            if artifact not in artifacts[category]:
                artifacts[category].append(artifact)
        
        def extract_from_item(item, context=""):
            if isinstance(item, dict):
                for key, value in item.items():
                    # Dosya artifactlarÄ±
                    if "file" in key.lower():
                        categorize_artifact("files", "files", {
                            "name": value if isinstance(value, str) else key,
                            "context": context,
                            "type": "file"
                        })
                    
                    # Log artifactlarÄ±
                    if "log" in key.lower():
                        categorize_artifact("logs", "logs", {
                            "name": value if isinstance(value, str) else key,
                            "context": context,
                            "type": "log"
                        })
                    
                    # Ä°letiÅŸim artifactlarÄ±
                    if any(comm in key.lower() for comm in ["sms", "call", "message", "email"]):
                        categorize_artifact("communications", "communications", {
                            "name": value if isinstance(value, str) else key,
                            "context": context,
                            "type": "communication"
                        })
                    
                    if isinstance(value, (dict, list)):
                        extract_from_item(value, context + "/" + key if context else key)
            elif isinstance(item, list):
                for i in item:
                    extract_from_item(i, context)
        
        extract_from_item(forensic_result)
        return artifacts

    def run_full_security_assessment(self, target_info):
        """
        Hedef mobil cihaz veya uygulama iÃ§in tam kapsamlÄ± gÃ¼venlik deÄŸerlendirmesi yapar.
        TÃ¼m analiz modÃ¼llerini sÄ±rayla Ã§alÄ±ÅŸtÄ±rÄ±r.
        """
        assessment_results = {
            "target_info": target_info,
            "start_time": datetime.now().isoformat(),
            "modules": {}
        }
        
        try:
            # OWASP analizi
            assessment_results["modules"]["owasp"] = self.chain.run({
                "input": f"OWASP Mobile Top 10 analizi gerÃ§ekleÅŸtir: {target_info}"
            })
            
            # Malware taramasÄ±
            assessment_results["modules"]["malware"] = self.analyze_malware_sample(target_info)
            
            # Forensik analiz
            assessment_results["modules"]["forensic"] = self.perform_forensic_analysis(target_info)
            
            # Exploit kontrolÃ¼
            assessment_results["modules"]["exploit"] = self.chain.run({
                "input": f"GÃ¼venlik aÃ§Ä±ÄŸÄ± exploit analizi: {target_info}"
            })
            
            # SonuÃ§larÄ± birleÅŸtir ve Ã¶zetle
            assessment_results["summary"] = self.generate_assessment_summary(assessment_results)
            assessment_results["recommendations"] = self.generate_recommendations(assessment_results)
            
        except Exception as e:
            assessment_results["error"] = str(e)
        finally:
            assessment_results["end_time"] = datetime.now().isoformat()
        
        return assessment_results

    def generate_assessment_summary(self, assessment_results):
        """
        TÃ¼m deÄŸerlendirme sonuÃ§larÄ±nÄ± Ã¶zetler ve genel bir risk profili oluÅŸturur.
        """
        summary = {
            "risk_profile": self.calculate_overall_risk(assessment_results),
            "key_findings": self.extract_key_findings(assessment_results),
            "affected_components": self.identify_affected_components(assessment_results),
            "statistics": self.calculate_assessment_statistics(assessment_results)
        }
        
        return summary

    def calculate_overall_risk(self, results):
        """
        TÃ¼m analiz sonuÃ§larÄ±nÄ± deÄŸerlendirerek genel risk seviyesini belirler.
        """
        risk_scores = []
        
        # Her modÃ¼lden risk skorlarÄ±nÄ± topla
        for module_name, module_results in results["modules"].items():
            if isinstance(module_results, dict):
                if "threat_level" in module_results:
                    risk_scores.append(self.risk_level_to_score(module_results["threat_level"]))
                if "risk_level" in module_results:
                    risk_scores.append(self.risk_level_to_score(module_results["risk_level"]))
        
        if not risk_scores:
            return "Unknown"
        
        # Ortalama risk skorunu hesapla
        average_score = sum(risk_scores) / len(risk_scores)
        
        # Skoru risk seviyesine dÃ¶nÃ¼ÅŸtÃ¼r
        if average_score >= 8:
            return "Critical"
        elif average_score >= 6:
            return "High"
        elif average_score >= 4:
            return "Medium"
        else:
            return "Low"

    def risk_level_to_score(self, level):
        """
        Risk seviyesini sayÄ±sal skora dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r
        """
        risk_scores = {
            "critical": 10,
            "high": 7,
            "medium": 4,
            "low": 1
        }
        return risk_scores.get(level.lower(), 0)

    def extract_key_findings(self, results):
        """
        TÃ¼m deÄŸerlendirmelerden Ã¶nemli bulgularÄ± Ã§Ä±karÄ±r
        """
        key_findings = []
        
        for module_name, module_results in results["modules"].items():
            if isinstance(module_results, dict):
                # OWASP bulgularÄ±
                if "vulnerabilities" in module_results:
                    for vuln in module_results["vulnerabilities"]:
                        if self.risk_level_to_score(vuln.get("risk_level", "low")) >= 4:
                            key_findings.append({
                                "type": "vulnerability",
                                "module": module_name,
                                "details": vuln
                            })
                
                # Malware bulgularÄ±
                if "iocs" in module_results:
                    for ioc_type, iocs in module_results["iocs"].items():
                        if iocs:  # BoÅŸ olmayan IOC'ler
                            key_findings.append({
                                "type": "indicator_of_compromise",
                                "module": module_name,
                                "ioc_type": ioc_type,
                                "count": len(iocs)
                            })
                
                # Forensik bulgular
                if "artifacts" in module_results:
                    for artifact_type, artifacts in module_results["artifacts"].items():
                        if artifacts:  # Ã–nemli artifactlar
                            key_findings.append({
                                "type": "forensic_artifact",
                                "module": module_name,
                                "artifact_type": artifact_type,
                                "count": len(artifacts)
                            })
        
        return key_findings

    def identify_affected_components(self, results):
        """
        GÃ¼venlik sorunlarÄ±ndan etkilenen sistem bileÅŸenlerini belirler
        """
        affected_components = {
            "system": set(),
            "applications": set(),
            "network_services": set(),
            "data_storage": set(),
            "communication": set()
        }
        
        def analyze_component(item, context=""):
            if isinstance(item, dict):
                # Sistem bileÅŸenleri
                if "system" in str(item).lower():
                    affected_components["system"].add(context)
                
                # Uygulama bileÅŸenleri
                if "app" in str(item).lower() or "application" in str(item).lower():
                    affected_components["applications"].add(context)
                
                # AÄŸ servisleri
                if "network" in str(item).lower() or "service" in str(item).lower():
                    affected_components["network_services"].add(context)
                
                # Veri depolama
                if "storage" in str(item).lower() or "data" in str(item).lower():
                    affected_components["data_storage"].add(context)
                
                # Ä°letiÅŸim bileÅŸenleri
                if "communication" in str(item).lower() or "message" in str(item).lower():
                    affected_components["communication"].add(context)
                
                for key, value in item.items():
                    if isinstance(value, (dict, list)):
                        analyze_component(value, f"{context}/{key}" if context else key)
            elif isinstance(item, list):
                for i in item:
                    analyze_component(i, context)
        
        for module_results in results["modules"].values():
            analyze_component(module_results)
        
        # Set'leri liste formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼r
        return {k: list(v) for k, v in affected_components.items() if v}

    def calculate_assessment_statistics(self, results):
        """
        GÃ¼venlik deÄŸerlendirmesi iÃ§in istatistiksel analiz yapar
        """
        stats = {
            "total_findings": 0,
            "risk_distribution": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0
            },
            "module_statistics": {},
            "temporal_analysis": {
                "first_finding": None,
                "last_finding": None,
                "assessment_duration": None
            }
        }
        
        # ModÃ¼l bazlÄ± istatistikler
        for module_name, module_results in results["modules"].items():
            stats["module_statistics"][module_name] = {
                "finding_count": 0,
                "unique_components": set(),
                "risk_levels": {
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0
                }
            }
            
            if isinstance(module_results, dict):
                self._analyze_module_statistics(
                    module_results,
                    stats["module_statistics"][module_name],
                    stats["risk_distribution"]
                )
        
        # Toplam bulgu sayÄ±sÄ±nÄ± hesapla
        stats["total_findings"] = sum(
            module_stats["finding_count"]
            for module_stats in stats["module_statistics"].values()
        )
        
        # Zamansal analiz
        if "start_time" in results and "end_time" in results:
            start_time = datetime.fromisoformat(results["start_time"])
            end_time = datetime.fromisoformat(results["end_time"])
            stats["temporal_analysis"]["assessment_duration"] = str(end_time - start_time)
        
        return stats

    def _analyze_module_statistics(self, module_results, module_stats, risk_distribution):
        """
        Tek bir modÃ¼l iÃ§in istatistiksel analiz yapar
        """
        def process_item(item):
            if isinstance(item, dict):
                # Risk seviyesi sayÄ±mÄ±
                if "risk_level" in item:
                    level = item["risk_level"].lower()
                    if level in module_stats["risk_levels"]:
                        module_stats["risk_levels"][level] += 1
                        risk_distribution[level] += 1
                
                # Etkilenen bileÅŸen analizi
                if "component" in item:
                    module_stats["unique_components"].add(item["component"])
                
                # Bulgu sayÄ±mÄ±
                if any(key in item for key in ["finding", "vulnerability", "artifact", "ioc"]):
                    module_stats["finding_count"] += 1
                
                for value in item.values():
                    if isinstance(value, (dict, list)):
                        process_item(value)
            elif isinstance(item, list):
                for i in item:
                    process_item(i)
        
        process_item(module_results)
        module_stats["unique_components"] = list(module_stats["unique_components"])

    def generate_final_report(self, assessment_results):
        """
        TÃ¼m gÃ¼venlik deÄŸerlendirmesini kapsamlÄ± bir rapora dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r
        """
        report = {
            "executive_summary": self._create_executive_summary(assessment_results),
            "technical_findings": self._organize_technical_findings(assessment_results),
            "risk_assessment": self._create_risk_assessment(assessment_results),
            "recommendations": self._create_detailed_recommendations(assessment_results),
            "appendices": self._create_appendices(assessment_results)
        }
        
        return report

    def _create_executive_summary(self, results):
        """
        Ãœst yÃ¶netim iÃ§in Ã¶zet rapor oluÅŸturur
        """
        summary = {
            "overview": {
                "assessment_date": results.get("start_time"),
                "duration": results.get("temporal_analysis", {}).get("assessment_duration"),
                "scope": self._determine_assessment_scope(results)
            },
            "key_findings": self._summarize_key_findings(results),
            "risk_overview": self._create_risk_overview(results),
            "immediate_actions": self._identify_immediate_actions(results)
        }
        
        return summary

    def _determine_assessment_scope(self, results):
        """
        DeÄŸerlendirmenin kapsamÄ±nÄ± belirler
        """
        scope = {
            "platforms": set(),
            "assessment_types": set(),
            "components": set()
        }
        
        def analyze_scope(item):
            if isinstance(item, dict):
                # Platform analizi
                if "platform" in item:
                    scope["platforms"].add(item["platform"])
                
                # DeÄŸerlendirme tÃ¼rÃ¼ analizi
                if "assessment_type" in item:
                    scope["assessment_types"].add(item["assessment_type"])
                
                # BileÅŸen analizi
                if "component" in item:
                    scope["components"].add(item["component"])
                
                for value in item.values():
                    if isinstance(value, (dict, list)):
                        analyze_scope(value)
            elif isinstance(item, list):
                for i in item:
                    analyze_scope(i)
        
        analyze_scope(results)
        return {k: list(v) for k, v in scope.items() if v}

def main():
    """
    Framework'Ã¼n ana Ã§alÄ±ÅŸtÄ±rma fonksiyonu
    """
    try:
        # Framework'Ã¼ baÅŸlat
        framework = AdvancedMobilePentestFramework("your-api-key")
        
        # Test hedefini tanÄ±mla
        target_info = {
            "platform": "Android",
            "os_version": "11.0",
            "device_model": "Samsung Galaxy S21",
            "apps": ["com.example.banking", "com.example.wallet"],
            "assessment_scope": ["malware", "forensic", "network"]
        }
        
        # Tam gÃ¼venlik deÄŸerlendirmesini Ã§alÄ±ÅŸtÄ±r
        results = framework.run_full_security_assessment(target_info)
        
        # SonuÃ§larÄ± raporla
        report = framework.generate_final_report(results)
        
        # Raporu JSON formatÄ±nda kaydet
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f"security_assessment_report_{timestamp}.json"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=4, ensure_ascii=False)
        
        print(f"\nGÃ¼venlik deÄŸerlendirmesi tamamlandÄ±. Rapor kaydedildi: {report_file}")
        
    except Exception as e:
        print(f"Hata oluÅŸtu: {str(e)}")

if __name__ == "__main__":
    main()from langchain.chains import LLMChain, SequentialChain
from langchain.chains.router import MultiPromptChain
from langchain.chains.router.llm_router import LLMRouterChain, RouterOutputParser
from langchain_groq import ChatGroq
from langchain.prompts import PromptTemplate, ChatPromptTemplate
from langchain.memory import ConversationBufferMemory
import json
from datetime import datetime
import hashlib
import base64

class AdvancedMobilePentestFramework:
    """
    GeliÅŸmiÅŸ Mobil GÃ¼venlik Test Framework'Ã¼
    Bu framework dÃ¶rt ana Ã¶zelliÄŸi birleÅŸtirir:
    1. Otomatik Exploit GeliÅŸtirme
    2. OWASP Mobile Top 10 Analizi
    3. Mobil Malware Analizi
    4. Forensik Analiz
    """
    
    def __init__(self, api_key):
        self.llm = ChatGroq(api_key=api_key, temperature=0.7)
        self.setup_memories()
        self.setup_chains()
        self.session_data = {}

    def setup_memories(self):
        """Her Ã¶zellik iÃ§in ayrÄ± bellek alanlarÄ± oluÅŸtur"""
        self.memories = {
            "exploit": ConversationBufferMemory(input_key="scenario", output_key="exploit"),
            "owasp": ConversationBufferMemory(input_key="app_info", output_key="vulnerabilities"),
            "malware": ConversationBufferMemory(input_key="sample", output_key="analysis"),
            "forensic": ConversationBufferMemory(input_key="device_data", output_key="findings")
        }

    def setup_chains(self):
        """TÃ¼m Ã¶zelleÅŸtirilmiÅŸ zincirleri hazÄ±rla"""
        
        # 1. Otomatik Exploit GeliÅŸtirme Zinciri
        exploit_template = """
        Bu mobil gÃ¼venlik aÃ§Ä±ÄŸÄ± iÃ§in gÃ¼venli bir PoC (Proof of Concept) exploit geliÅŸtir:
        {scenario}

        LÃ¼tfen aÅŸaÄŸÄ±daki yapÄ±yÄ± kullan:
        1. Zafiyet Analizi
            - Etkilenen bileÅŸen
            - SaldÄ±rÄ± vektÃ¶rÃ¼
            - CVSS skoru
        
        2. Exploit DetaylarÄ±
            - Gerekli koÅŸullar
            - Teknik adÄ±mlar
            - BaÅŸarÄ± kriterleri
        
        3. GÃ¼venlik Ã–nlemleri
            - Test ortamÄ± gereksinimleri
            - Risk azaltma adÄ±mlarÄ±
            - Yasal uyarÄ±lar

        4. Kod Åablonu
            - Pseudo kod
            - Test senaryolarÄ±
            - DoÄŸrulama adÄ±mlarÄ±

        JSON formatÄ±nda dÃ¶ndÃ¼r.
        """

        self.exploit_chain = LLMChain(
            llm=self.llm,
            prompt=PromptTemplate(
                input_variables=["scenario"],
                template=exploit_template
            ),
            memory=self.memories["exploit"],
            verbose=True
        )

        # 2. OWASP Mobile Top 10 Analiz Zinciri
        owasp_template = """
        Bu mobil uygulamayÄ± OWASP Mobile Top 10 kriterlerine gÃ¶re analiz et:
        {app_info}

        Her kategori iÃ§in analiz yap:
        1. M1: Uygunsuz Platform KullanÄ±mÄ±
        2. M2: GÃ¼vensiz Veri Depolama
        3. M3: GÃ¼vensiz Ä°letiÅŸim
        4. M4: GÃ¼vensiz Kimlik DoÄŸrulama
        5. M5: Yetersiz Kriptografi
        6. M6: GÃ¼vensiz Yetkilendirme
        7. M7: Ä°stemci Kodu Kalitesi
        8. M8: Kod Tampering
        9. M9: Ters MÃ¼hendislik
        10. M10: Fazladan Ä°ÅŸlevsellik

        Her kategori iÃ§in:
        - Risk seviyesi
        - Bulunan zafiyetler
        - DÃ¼zeltme Ã¶nerileri
        - Test senaryolarÄ±

        JSON formatÄ±nda dÃ¶ndÃ¼r.
        """

        self.owasp_chain = LLMChain(
            llm=self.llm,
            prompt=PromptTemplate(
                input_variables=["app_info"],
                template=owasp_template
            ),
            memory=self.memories["owasp"],
            verbose=True
        )

        # 3. Mobil Malware Analiz Zinciri
        malware_template = """
        Bu mobil malware Ã¶rneÄŸini analiz et:
        {sample}

        Analiz alanlarÄ±:
        1. Statik Analiz
            - Paket bilgileri
            - Ä°zinler
            - Manifest analizi
            - Kod imzalarÄ±
        
        2. Dinamik Analiz
            - AÄŸ aktivitesi
            - API Ã§aÄŸrÄ±larÄ±
            - Dosya sistemi deÄŸiÅŸiklikleri
            - DavranÄ±ÅŸ analizi
        
        3. Tehdit Analizi
            - Malware tÃ¼rÃ¼
            - Yetenekleri
            - Hedef sistemler
            - YayÄ±lma mekanizmasÄ±
        
        4. Ã–nlemler
            - Tespit yÃ¶ntemleri
            - Koruma mekanizmalarÄ±
            - Temizleme prosedÃ¼rleri

        JSON formatÄ±nda dÃ¶ndÃ¼r.
        """

        self.malware_chain = LLMChain(
            llm=self.llm,
            prompt=PromptTemplate(
                input_variables=["sample"],
                template=malware_template
            ),
            memory=self.memories["malware"],
            verbose=True
        )

        # 4. Forensik Analiz Zinciri
        forensic_template = """
        Bu mobil cihaz iÃ§in forensik analiz gerÃ§ekleÅŸtir:
        {device_data}

        Analiz alanlarÄ±:
        1. Dosya Sistemi Analizi
            - SilinmiÅŸ dosyalar
            - Sistem loglarÄ±
            - Uygulama verileri
            - Medya dosyalarÄ±
        
        2. Bellek Analizi
            - RAM dÃ¶kÃ¼mÃ¼
            - GeÃ§ici dosyalar
            - Åifreli veriler
            - Ã‡alÄ±ÅŸan iÅŸlemler
        
        3. Ä°letiÅŸim Analizi
            - SMS/MMS
            - Arama kayÄ±tlarÄ±
            - E-posta
            - MesajlaÅŸma uygulamalarÄ±
        
        4. Uygulama Analizi
            - YÃ¼klenmiÅŸ uygulamalar
            - Uygulama geÃ§miÅŸi
            - Cache verileri
            - Kimlik bilgileri

        5. Zaman Ã‡izelgesi
            - Ã–nemli olaylar
            - Dosya deÄŸiÅŸiklikleri
            - KullanÄ±cÄ± aktivitesi
            - Sistem olaylarÄ±

        JSON formatÄ±nda dÃ¶ndÃ¼r.
        """

        self.forensic_chain = LLMChain(
            llm=self.llm,
            prompt=PromptTemplate(
                input_variables=["device_data"],
                template=forensic_template
            ),
            memory=self.memories["forensic"],
            verbose=True
        )

        # Router yapÄ±landÄ±rmasÄ±
        router_template = """
        Verilen mobil gÃ¼venlik analiz talebini en uygun kategoriye yÃ¶nlendir.
        
        Analiz talebi: {input}
        
        Kategoriler:
        1. exploit (GÃ¼venlik aÃ§Ä±ÄŸÄ± exploit geliÅŸtirme)
        2. owasp (OWASP Mobile Top 10 analizi)
        3. malware (KÃ¶tÃ¼cÃ¼l yazÄ±lÄ±m analizi)
        4. forensic (Adli analiz)

        Sadece kategori ismini dÃ¶ndÃ¼r: exploit, owasp, malware, veya forensic
        """

        self.router_chain = LLMRouterChain.from_llm(
            self.llm,
            router_template,
            RouterOutputParser()
        )

        # Multi-prompt zinciri oluÅŸtur
        self.chain = MultiPromptChain(
            router_chain=self.router_chain,
            destination_chains={
                "exploit": self.exploit_chain,
                "owasp": self.owasp_chain,
                "malware": self.malware_chain,
                "forensic": self.forensic_chain
            },
            default_chain=self.owasp_chain,
            verbose=True
        )

    def generate_report_id(self):
        """Benzersiz rapor ID'si oluÅŸtur"""
        timestamp = datetime.now().isoformat()
        return hashlib.sha256(timestamp.encode()).hexdigest()[:12]

    def run_analysis(self, input_data):
        """Tam gÃ¼venlik analizini Ã§alÄ±ÅŸtÄ±r"""
        report_id = self.generate_report_id()
        self.session_data[report_id] = {
            "start_time": datetime.now(),
            "input_data": input_data,
            "status": "running"
        }

        try:
            # Ana analizi Ã§alÄ±ÅŸtÄ±r
            result = self.chain.run(input_data)
            
            # SonuÃ§larÄ± parse et
            parsed_result = self.parse_results(result)
            
            # DetaylÄ± rapor oluÅŸtur
            report = self.generate_detailed_report(parsed_result, report_id)
            
            self.session_data[report_id].update({
                "status": "completed",
                "end_time": datetime.now(),
                "results": parsed_result,
                "report": report
            })
            
            return report
            
        except Exception as e:
            self.session_data[report_id].update({
                "status": "failed",
                "end_time": datetime.now(),
                "error": str(e)
            })
            raise

    def parse_results(self, results):
        """Analiz sonuÃ§larÄ±nÄ± parse et"""
        try:
            if isinstance(results, str):
                return json.loads(results)
            return results
        except json.JSONDecodeError:
            return {"raw_output": results}

    def generate_detailed_report(self, results, report_id):
        """DetaylÄ± gÃ¼venlik raporu oluÅŸtur"""
        session = self.session_data[report_id]
        
        return {
            "report_id": report_id,
            "timestamp": datetime.now().isoformat(),
            "analysis_duration": str(datetime.now() - session["start_time"]),
            "summary": {
                "title": "Mobil GÃ¼venlik Analiz Raporu",
                "scope": self.determine_analysis_scope(results),
                "risk_level": self.calculate_risk_level(results),
                "findings_count": self.count_findings(results)
            },
            "detailed_findings": results,
            "recommendations": self.generate_recommendations(results),
            "metadata": {
                "framework_version": "2.0.0",
                "analysis_modules": list(self.chain.destination_chains.keys())
            }
        }

    def determine_analysis_scope(self, results):
        """Analiz kapsamÄ±nÄ± belirle"""
        scope_indicators = {
            "exploit": ["vulnerability", "exploit", "poc"],
            "owasp": ["authentication", "cryptography", "authorization"],
            "malware": ["malicious", "trojan", "spyware"],
            "forensic": ["filesystem", "memory", "communication"]
        }
        
        detected_scopes = []
        results_str = json.dumps(results).lower()
        
        for scope, indicators in scope_indicators.items():
            if any(ind in results_str for ind in indicators):
                detected_scopes.append(scope)
        
        return detected_scopes

    def calculate_risk_level(self, results):
        """Genel risk seviyesini hesapla"""
        risk_scores = {
            "critical": 4,
            "high": 3,
            "medium": 2,
            "low": 1
        }
        
        total_score = 0
        count = 0
        
        def process_item(item):
            nonlocal total_score, count
            if isinstance(item, dict):
                for key, value in item.items():
                    if key in ["risk", "risk_level", "severity"]:
                        if value.lower() in risk_scores:
                            total_score += risk_scores[value.lower()]
                            count += 1
                    elif isinstance(value, (dict, list)):
                        extract_recommendations(value, category)
        
        # SonuÃ§larÄ± analiz et ve Ã¶nerileri kategorize et
        for key, value in results.items():
            if isinstance(value, dict) and "risk_level" in value:
                if value["risk_level"].lower() in ["critical", "high"]:
                    extract_recommendations(value, "immediate_actions")
                elif value["risk_level"].lower() == "medium":
                    extract_recommendations(value, "short_term")
                else:
                    extract_recommendations(value, "long_term")
            elif isinstance(value, (dict, list)):
                extract_recommendations(value)
        
        return recommendations

def run_test_scenarios(self):
    """Test senaryolarÄ±nÄ± Ã§alÄ±ÅŸtÄ±r"""
    scenarios = [
        # Exploit GeliÅŸtirme Senaryosu
        {
            "type": "exploit",
            "description": """
            Android uygulamasÄ±nda deeplink iÅŸleme zafiyeti tespit edildi.
            Intent filtreleri doÄŸru yapÄ±landÄ±rÄ±lmamÄ±ÅŸ ve arbitrary URL aÃ§Ä±lmasÄ±na
            izin veriyor. PoC exploit geliÅŸtirmemiz gerekiyor.
            """,
            "expected_output": ["vulnerability_analysis", "exploit_code", "mitigation"]
        },
        
        # OWASP Analiz Senaryosu
        {
            "type": "owasp",
            "description": """
            Yeni geliÅŸtirilen finans uygulamasÄ±nÄ±n OWASP Mobile Top 10
            kriterlerine gÃ¶re gÃ¼venlik deÄŸerlendirmesini yapÄ±n. Uygulama
            SSL pinning kullanÄ±yor ve root detection iÃ§eriyor.
            """,
            "expected_output": ["m1_platform_usage", "m3_communication", "m5_cryptography"]
        },
        
        # Malware Analiz Senaryosu
        {
            "type": "malware",
            "description": """
            KullanÄ±cÄ±lar bir Android bankacÄ±lÄ±k trojanÄ± tarafÄ±ndan hedef alÄ±nÄ±yor.
            Malware WhatsApp Ã¼zerinden yayÄ±lÄ±yor ve kendini meÅŸru bir kripto
            cÃ¼zdan uygulamasÄ± olarak gÃ¶steriyor. APK dosyasÄ±nÄ± analiz edin.
            """,
            "expected_output": ["static_analysis", "dynamic_analysis", "threat_analysis"]
        },
        
        # Forensik Analiz Senaryosu
        {
            "type": "forensic",
            "description": """
            Åirket telefonunda veri sÄ±zÄ±ntÄ±sÄ± ÅŸÃ¼phesi var. Son 30 gÃ¼nlÃ¼k
            aktiviteyi analiz edin. Ã–zellikle WhatsApp, e-posta ve dosya
            transfer aktivitelerine odaklanÄ±n.
            """,
            "expected_output": ["filesystem_analysis", "communication_analysis", "timeline"]
        }
    ]
    
    test_results = []
    for scenario in scenarios:
        try:
            print(f"\nTest Senaryosu: {scenario['type']}")
            result = self.run_analysis(scenario['description'])
            
            # Beklenen Ã§Ä±ktÄ±larÄ± kontrol et
            validation = self.validate_test_output(result, scenario['expected_output'])
            
            test_results.append({
                "scenario_type": scenario['type'],
                "status": "success" if validation['valid'] else "partial",
                "validation": validation,
                "result": result
            })
            
        except Exception as e:
            test_results.append({
                "scenario_type": scenario['type'],
                "status": "failed",
                "error": str(e)
            })
    
    return test_results

def validate_test_output(self, result, expected_outputs):
    """Test sonuÃ§larÄ±nÄ± doÄŸrula"""
    validation = {
        "valid": True,
        "missing_outputs": [],
        "found_outputs": []
    }
    
    result_str = json.dumps(result).lower()
    
    for expected in expected_outputs:
        if expected.lower() in result_str:
            validation["found_outputs"].append(expected)
        else:
            validation["missing_outputs"].append(expected)
            validation["valid"] = False
    
    return validation

# Ã–rnek kullanÄ±m
def main():
    """Ana test sÃ¼recini Ã§alÄ±ÅŸtÄ±r"""
    try:
        framework = AdvancedMobilePentestFramework("your-api-key")
        
        print("Mobil GÃ¼venlik Test Framework'Ã¼ BaÅŸlatÄ±ldÄ±")
        print("\nTest SenaryolarÄ± Ã‡alÄ±ÅŸtÄ±rÄ±lÄ±yor...")
        
        results = framework.run_test_scenarios()
        
        print("\nTest SonuÃ§larÄ±:")
        for result in results:
            print(f"\nSenaryo: {result['scenario_type']}")
            print(f"Durum: {result['status']}")
            
            if result['status'] == "success":
                print("Validasyon:")
                print(f"- Bulunan Ã§Ä±ktÄ±lar: {', '.join(result['validation']['found_outputs'])}")
            elif result['status'] == "partial":
                print("Eksik Ã§Ä±ktÄ±lar:")
                print(f"- {', '.join(result['validation']['missing_outputs'])}")
            else:
                print(f"Hata: {result['error']}")
        
        print("\nDetaylÄ± raporlar 'test_results' dizininde oluÅŸturuldu.")
        
    except Exception as e:
        print(f"Framework baÅŸlatÄ±lÄ±rken hata oluÅŸtu: {str(e)}")

if __name__ == "__main__":
    main(), (dict, list)):
                        process_item(value)
            elif isinstance(item, list):
                for i in item:
                    process_item(i)
        
        process_item(results)
        
        if count == 0:
            return "Unknown"
            
        average_score = total_score / count
        
        if average_score >= 3.5:
            return "Critical"
        elif average_score >= 2.5:
            return "High"
        elif average_score >= 1.5:
            return "Medium"
        else:
            return "Low"

    def count_findings(self, results):
        """BulgularÄ± kategorilere gÃ¶re say"""
        counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
        
        def count_item(item):
            if isinstance(item, dict):
                for key, value in item.items():
                    if key in ["risk", "risk_level", "severity"]:
                        level = value.lower()
                        if level in counts:
                            counts[level] += 1
                    elif isinstance(value, (dict, list)):
                        count_item(value)
            elif isinstance(item, list):
                for i in item:
                    count_item(i)
        
        count_item(results)
        return counts

    def generate_recommendations(self, results):
        """Analiz sonuÃ§larÄ±na gÃ¶re Ã¶neriler oluÅŸtur"""
        recommendations = {
            "immediate_actions": [],
            "short_term": [],
            "long_term": [],
            "best_practices": []
        }
        
        def extract_recommendations(item, category="best_practices"):
            if isinstance(item, dict):
                for key, value in item.items():
                    if "recommendation" in key.lower() or "solution" in key.lower():
                        if isinstance(value, str):
                            recommendations[category].append(value)
                        elif isinstance(value, list):
                            recommendations[category].extend(value)
                    elif isinstance(value, (dict, list)):
                        extract_recommendations(value, category)
            elif isinstance(item, list):
                for i in item:
                    extract_recommendations(i, category)
```





 LangChain aslÄ±nda saldÄ±rÄ±larÄ± kendisi yapmÄ±yor - o bir Ã§erÃ§eve (framework) yani bir organizasyon aracÄ±. Bunu gÃ¼nlÃ¼k hayattan bir Ã¶rnekle aÃ§Ä±klayayÄ±m:

LangChain'i bir ÅŸef restoranÄ±ndaki baÅŸ garsona benzetebiliriz. BaÅŸ garson yemekleri piÅŸirmiyor (saldÄ±rÄ±larÄ± yapmÄ±yor), ancak:

- MÃ¼ÅŸterinin sipariÅŸini alÄ±yor (bizim talimatlarÄ±mÄ±zÄ±)
- Bu sipariÅŸi mutfaÄŸa iletiyor (LLM'e gÃ¶nderiyor)
- Gelen yemekleri organize ediyor (sonuÃ§larÄ± dÃ¼zenliyor)
- Servis kalitesini kontrol ediyor (Ã§Ä±ktÄ±larÄ± yÃ¶netiyor)

LangChain bizim verdiÄŸimiz talimatlarÄ± (prompts) alÄ±p:

1. Ã–nce bunlarÄ± organize ediyor
2. Groq gibi bir LLM'e gÃ¶nderiyor
3. Gelen cevaplarÄ± dÃ¼zenliyor
4. SonuÃ§larÄ± bize sunuyor

Yani biz bir gÃ¼venlik aÃ§Ä±ÄŸÄ± analizi istediÄŸimizde:

- LangChain bu isteÄŸi dÃ¼zenli bir formata sokuyor
- LLM'e gÃ¶nderiyor
- LLM analizi yapÄ±yor ve cevap veriyor
- LangChain bu cevabÄ± alÄ±p dÃ¼zenli bir ÅŸekilde bize sunuyor