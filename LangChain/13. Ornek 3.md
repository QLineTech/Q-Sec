```
"high": ["architecture", "redesign", "major", "system-wide", "third-party"],
            "medium": ["configuration", "update", "modification", "component"],
            "low": ["setting", "minor", "documentation", "single-file"]
        }
        
        description = finding.get("description", "").lower()
        recommendation = finding.get("recommendation", "").lower()
        combined_text = f"{description} {recommendation}"
        
        # Çaba seviyesini belirle
        for level, indicators in effort_indicators.items():
            if any(indicator in combined_text for indicator in indicators):
                return level
        
        return "medium"  # Varsayılan seviye

    def _analyze_cwe_coverage(self, results):
        """
        Common Weakness Enumeration (CWE) kapsamını analiz eder.
        Bulunan zafiyetleri CWE kategorileriyle eşleştirir.
        """
        cwe_coverage = {
            "analyzed_weaknesses": [],
            "coverage_statistics": {
                "total_cwe_mapped": 0,
                "unique_cwe_categories": set(),
                "severity_distribution": {}
            },
            "top_weakness_categories": []
        }
        
        def map_to_cwe(item):
            if isinstance(item, dict):
                if "cwe_id" in item:
                    cwe_info = {
                        "cwe_id": item["cwe_id"],
                        "description": item.get("description", ""),
                        "severity": item.get("severity", ""),
                        "finding_count": 1
                    }
                    cwe_coverage["analyzed_weaknesses"].append(cwe_info)
                    cwe_coverage["coverage_statistics"]["unique_cwe_categories"].add(item["cwe_id"])
                    
                    severity = item.get("severity", "unknown").lower()
                    if severity not in cwe_coverage["coverage_statistics"]["severity_distribution"]:
                        cwe_coverage["coverage_statistics"]["severity_distribution"][severity] = 0
                    cwe_coverage["coverage_statistics"]["severity_distribution"][severity] += 1
                
                for value in item.values():
                    if isinstance(value, (dict, list)):
                        map_to_cwe(value)
            elif isinstance(item, list):
                for i in item:
                    map_to_cwe(i)
        
        map_to_cwe(results)
        
        # İstatistikleri güncelle
        cwe_coverage["coverage_statistics"]["total_cwe_mapped"] = len(cwe_coverage["analyzed_weaknesses"])
        cwe_coverage["coverage_statistics"]["unique_cwe_categories"] = len(cwe_coverage["coverage_statistics"]["unique_cwe_categories"])
        
        # En çok görülen zayıflık kategorilerini belirle
        category_counts = {}
        for weakness in cwe_coverage["analyzed_weaknesses"]:
            cwe_id = weakness["cwe_id"]
            if cwe_id not in category_counts:
                category_counts[cwe_id] = {
                    "count": 0,
                    "description": weakness["description"],
                    "severity": weakness["severity"]
                }
            category_counts[cwe_id]["count"] += 1
        
        # En çok görülen kategorileri sırala
        sorted_categories = sorted(
            category_counts.items(),
            key=lambda x: x[1]["count"],
            reverse=True
        )
        
        cwe_coverage["top_weakness_categories"] = [
            {
                "cwe_id": cwe_id,
                "count": info["count"],
                "description": info["description"],
                "severity": info["severity"]
            }
            for cwe_id, info in sorted_categories[:5]  # İlk 5 kategori
        ]
        
        return cwe_coverage

    def _analyze_compliance_status(self, results):
        """
        Genel uyumluluk durumunu analiz eder.
        Farklı güvenlik standartlarına göre uyumluluk seviyesini belirler.
        """
        compliance_status = {
            "overall_status": self._calculate_overall_compliance(results),
            "standard_specific_status": self._analyze_standard_compliance(results),
            "compliance_gaps": self._identify_compliance_gaps(results),
            "improvement_roadmap": self._create_compliance_roadmap(results)
        }
        
        return compliance_status

    def _calculate_overall_compliance(self, results):
        """
        Genel uyumluluk seviyesini hesaplar.
        Tüm güvenlik standartlarını ve gereksinimleri değerlendirir.
        """
        compliance_scores = []
        
        # Her modül için uyumluluk puanı hesapla
        for module_name, module_results in results.get("modules", {}).items():
            if isinstance(module_results, dict):
                score = self._calculate_module_compliance(module_results)
                compliance_scores.append(score)
        
        if not compliance_scores:
            return {
                "level": "Unknown",
                "score": 0,
                "details": "No compliance data available"
            }
        
        average_score = sum(compliance_scores) / len(compliance_scores)
        
        # Seviye belirleme
        if average_score >= 90:
            return {
                "level": "Full Compliance",
                "score": average_score,
                "details": "Meets or exceeds all major security requirements"
            }
        elif average_score >= 75:
            return {
                "level": "Substantial Compliance",
                "score": average_score,
                "details": "Meets most security requirements with minor gaps"
            }
        elif average_score >= 60:
            return {
                "level": "Partial Compliance",
                "score": average_score,
                "details": "Meets basic requirements but needs improvement"
            }
        else:
            return {
                "level": "Non-Compliant",
                "score": average_score,
                "details": "Significant compliance gaps exist"
            }

    def _identify_immediate_actions(self, results):
        """
        Acil eylem gerektiren sorunları belirler.
        Kritik güvenlik açıkları ve yüksek riskli bulgular için eylem planı oluşturur.
        """
        immediate_actions = []
        
        # Her modülü kontrol et
        for module_name, module_results in results.get("modules", {}).items():
            if isinstance(module_results, dict):
                # Kritik bulguları bul
                findings = module_results.get("findings", [])
                if isinstance(findings, list):
                    for finding in findings:
                        if finding.get("risk_level", "").lower() in ["critical", "high"]:
                            action = {
                                "title": finding.get("title", "Unnamed Finding"),
                                "risk_level": finding.get("risk_level", "Unknown"),
                                "module": module_name,
                                "impact": finding.get("impact", "Unknown impact"),
                                "mitigation": finding.get("mitigation", "No mitigation provided"),
                                "deadline": "Immediate",
                                "resources_needed": self._estimate_required_resources(finding)
                            }
                            immediate_actions.append(action)
        
        # Eylemleri önceliklendir
        immediate_actions.sort(
            key=lambda x: (
                0 if x["risk_level"].lower() == "critical" else 1,
                1 if x["risk_level"].lower() == "high" else 2
            )
        )
        
        return immediate_actions

    def _estimate_required_resources(self, finding):
        """
        Bir bulgunun düzeltilmesi için gereken kaynakları tahmin eder.
        İnsan kaynağı, zaman ve olası maliyeti değerlendirir.
        """
        resources = {
            "personnel": self._estimate_personnel_needs(finding),
            "time": self._estimate_time_requirement(finding),
            "cost": self._estimate_cost(finding),
            "dependencies": self._identify_dependencies(finding)
        }
        
        return resources

    def _estimate_personnel_needs(self, finding):
        """
        Gerekli personel kaynaklarını tahmin eder.
        """
        # Bulgunun karmaşıklığına göre personel ihtiyacını belirle
        complexity = finding.get("complexity", "medium").lower()
        
        if complexity == "high":
            return {
                "security_engineer": 2,
                "developer": 2,
                "qa_engineer": 1,
                "system_admin": 1
            }
        elif complexity == "medium":
            return {
                "security_engineer": 1,
                "developer": 1,
                "qa_engineer": 1
            }
        else:
            return {
                "security_engineer": 1,
                "developer": 1
            }

    def _estimate_time_requirement(self, finding):
        """
        Düzeltme için gereken süreyi tahmin eder.
        """
        base_time = {
            "critical": 5,  # günler
            "high": 10,
            "medium": 15,
            "low": 20
        }
        
        risk_level = finding.get("risk_level", "low").lower()
        complexity_multiplier = {
            "high": 2.0,
            "medium": 1.5,
            "low": 1.0
        }
        
        complexity = finding.get("complexity", "medium").lower()
        
        estimated_days = base_time.get(risk_level, 20) * complexity_multiplier.get(complexity, 1.0)
        
        return {
            "estimated_days": estimated_days,
            "confidence_level": "medium",
            "factors": [
                "risk_level",
                "complexity",
                "dependencies"
            ]
        }

    def _estimate_cost(self, finding):
        """
        Düzeltme maliyetini tahmin eder.
        """
        # Personel maliyetleri (adam/gün)
        daily_rates = {
            "security_engineer": 800,
            "developer": 600,
            "qa_engineer": 500,
            "system_admin": 550
        }
        
        personnel = self._estimate_personnel_needs(finding)
        time_estimate = self._estimate_time_requirement(finding)
        
        # Toplam personel maliyeti
        personnel_cost = sum(
            count * daily_rates[role] * time_estimate["estimated_days"]
            for role, count in personnel.items()
        )
        
        # Ek maliyetler
        additional_costs = {
            "tools_and_licenses": 0.15 * personnel_cost,  # Personel maliyetinin %15'i
            "training": 0.10 * personnel_cost,  # Personel maliyetinin %10'u
            "contingency": 0.20 * personnel_cost  # Personel maliyetinin %20'si
        }
        
        total_cost = personnel_cost + sum(additional_costs.values())
        
        return {
            "total_estimated_cost": total_cost,
            "breakdown": {
                "personnel_cost": personnel_cost,
                "additional_costs": additional_costs
            },
            "confidence_level": "medium",
            "notes": [
                "Costs are rough estimates",
                "Actual costs may vary based on implementation details",
                "Does not include long-term maintenance costs"
            ]
        }

    def _identify_dependencies(self, finding):
        """
        Düzeltme için gereken bağımlılıkları belirler.
        """
        dependencies = {
            "systems": [],
            "third_party": [],
            "internal": []
        }
        
        # Sistem bağımlılıkları
        if "system" in finding.get("affected_components", []):
            dependencies["systems"].extend([
                "Operating System",
                "Security Controls",
                "Network Infrastructure"
            ])
        
        # Üçüncü parti bağımlılıklar
        if "third_party" in finding.get("affected_components", []):
            dependencies["third_party"].extend([
                "External APIs",
                "Third-party Libraries",
                "Cloud Services"
            ])
        
        # İç bağımlılıklar
        if "internal" in finding.get("affected_components", []):
            dependencies["internal"].extend([
                "Internal APIs",
                "Database Systems",
                "Authentication Services"
            ])
        
        return dependencies

    def generate_executive_dashboard(self, results):
        """
        Üst yönetim için görsel dashboard oluşturur.
        """
        dashboard = {
            "summary_metrics": self._calculate_summary_metrics(results),
            "risk_overview": self._create_risk_overview(results),
            "key_findings": self._summarize_key_findings(results),
            "improvement_metrics": self._calculate_improvement_metrics(results),
            "compliance_status": self._analyze_compliance_status(results),
            "recommendation_timeline": self._create_recommendation_timeline(results)
        }
        
        return dashboard

    def _calculate_improvement_metrics(self, results):
        """
        İyileştirme metriklerini hesaplar ve trend analizi yapar.
        """
        metrics = {
            "security_score": self._calculate_security_score(results),
            "risk_reduction": self._calculate_risk_reduction(results),
            "implementation_progress": self._calculate_implementation_progress(results),
            "effectiveness_metrics": self._calculate_effectiveness_metrics(results)
        }
        
        return metrics

    def _create_recommendation_timeline(self, results):
        """
        Öneriler için zaman çizelgesi oluşturur.
        """
        timeline = {
            "immediate": [],  # 0-24 saat
            "short_term": [], # 1-7 gün
            "medium_term": [], # 1-4 hafta
            "long_term": []   # 1+ ay
        }
        
        # Her bulgu için zaman planlaması yap
        for finding in results.get("findings", []):
            time_frame = self._determine_time_frame(finding)
            
            recommendation = {
                "title": finding.get("title", "Unnamed Finding"),
                "risk_level": finding.get("risk_level", "Unknown"),
                "estimated_effort": self._estimate_remediation_effort(finding),
                "dependencies": self._identify_dependencies(finding)
            }
            
            timeline[time_frame].append(recommendation)
        
        return timeline

    def _determine_time_frame(self, finding):
        """
        Bir bulgu için uygun zaman çerçevesini belirler.
        """
        risk_level = finding.get("risk_level", "").lower()
        complexity = finding.get("complexity", "").lower()
        
        if risk_level == "critical":
            return "immediate"
        elif risk_level == "high":
            return "short_term"
        elif complexity == "high":
            return "long_term"
        else:
            return "medium_term"

if __name__ == "__main__":
    try:
        # API anahtarını güvenli bir şekilde al
        api_key = os.getenv("GROQ_API_KEY", "your-api-key")
        
        # Framework'ü başlat
        framework = AdvancedMobilePentestFramework(api_key)
        
        print("\n🚀 Gelişmiş Mobil Güvenlik Test Framework'ü Başlatıldı")
        print("\n📱 Test Senaryoları Hazırlanıyor...")

        # Test senaryolarını hazırla
        test_scenarios = [
            {
                "name": "Android Banking App Analysis",
                "target_info": {
                    "platform": "Android",
                    "os_version": "12",
                    "device_model": "Samsung Galaxy S21",
                    "app_package": "com.example.banking",
                    "app_version": "2.1.0",
                    "assessment_scope": ["malware", "owasp", "forensic"]
                },
                "expected_analysis_modules": ["malware", "owasp", "forensic"]
            },
            {
                "name": "iOS Cryptocurrency Wallet Security",
                "target_info": {
                    "platform": "iOS",
                    "os_version": "15.5",
                    "device_model": "iPhone 13 Pro",
                    "app_bundle": "com.example.cryptowallet",
                    "app_version": "1.5.2",
                    "assessment_scope": ["owasp", "forensic", "exploit"]
                },
                "expected_analysis_modules": ["owasp", "forensic", "exploit"]
            },
            {
                "name": "Mobile Game Security Assessment",
                "target_info": {
                    "platform": "Android",
                    "os_version": "11",
                    "device_model": "Google Pixel 6",
                    "app_package": "com.example.game",
                    "app_version": "3.0.1",
                    "assessment_scope": ["malware", "exploit"]
                },
                "expected_analysis_modules": ["malware", "exploit"]
            }
        ]

        # Sonuçları saklamak için liste
        assessment_results = []

        # Her senaryo için güvenlik değerlendirmesi yap
        for scenario in test_scenarios:
            print(f"\n🔍 Test Senaryosu Başlatılıyor: {scenario['name']}")
            print("=" * 50)
            
            try:
                # Güvenlik değerlendirmesini çalıştır
                results = framework.run_full_security_assessment(scenario['target_info'])
                
                # Executive dashboard oluştur
                dashboard = framework.generate_executive_dashboard(results)
                
                # Sonuçları kaydet
                assessment_results.append({
                    "scenario": scenario,
                    "results": results,
                    "dashboard": dashboard
                })
                
                # Özet rapor göster
                print(f"\n✅ Değerlendirme Tamamlandı: {scenario['name']}")
                print(f"📊 Risk Seviyesi: {results.get('summary', {}).get('risk_level', 'Unknown')}")
                print(f"🎯 Bulunan Toplam Zafiyet: {len(results.get('findings', []))}")
                
                # Kritik bulguları göster
                critical_findings = [f for f in results.get('findings', []) 
                                  if f.get('risk_level', '').lower() == 'critical']
                if critical_findings:
                    print("\n⚠️ Kritik Bulgular:")
                    for finding in critical_findings:
                        print(f"- {finding.get('title', 'Unnamed Finding')}")
                
            except Exception as e:
                print(f"\n❌ Hata: Senaryo çalıştırılırken bir sorun oluştu: {str(e)}")
                continue

        # Tüm sonuçları dosyaya kaydet
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_dir = "security_assessments"
        os.makedirs(output_dir, exist_ok=True)
        
        for result in assessment_results:
            scenario_name = result['scenario']['name'].lower().replace(' ', '_')
            filename = f"{output_dir}/assessment_{scenario_name}_{timestamp}.json"
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=4, ensure_ascii=False)
            
            print(f"\n📝 Rapor kaydedildi: {filename}")

        # Genel özet göster
        print("\n📊 Genel Değerlendirme Özeti")
        print("=" * 50)
        print(f"Toplam Test Edilen Senaryo: {len(assessment_results)}")
        
        # Risk dağılımını hesapla
        risk_distribution = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0
        }
        
        total_findings = 0
        for result in assessment_results:
            findings = result['results'].get('findings', [])
            total_findings += len(findings)
            
            for finding in findings:
                risk_level = finding.get('risk_level', '').lower()
                if risk_level in risk_distribution:
                    risk_distribution[risk_level] += 1
        
        print(f"Toplam Bulunan Zafiyet: {total_findings}")
        print("\nRisk Dağılımı:")
        for level, count in risk_distribution.items():
            print(f"- {level.capitalize()}: {count}")
        
        # Önerilen aksiyonları göster
        print("\n🎯 Önerilen Öncelikli Aksiyonlar:")
        for result in assessment_results:
            critical_findings = [f for f in result['results'].get('findings', [])
                               if f.get('risk_level', '').lower() in ['critical', 'high']]
            
            if critical_findings:
                print(f"\n{result['scenario']['name']}:")
                for finding in critical_findings[:3]:  # İlk 3 kritik bulgu
                    print(f"- {finding.get('title', 'Unnamed Finding')}")
                    print(f"  Öneri: {finding.get('recommendation', 'No recommendation provided')}")

        print("\n✨ Güvenlik Değerlendirmesi Tamamlandı!")
        print("Detaylı raporlar 'security_assessments' dizininde bulunabilir.")

    except KeyboardInterrupt:
        print("\n\n⚠️ Test süreci kullanıcı tarafından durduruldu.")
        sys.exit(1)
    except Exception as e:
        print(f"\n❌ Kritik hata: {str(e)}")
        sys.exit(1)
    def _summarize_key_findings(self, results):
        """
        Önemli bulguları özetler ve öncelikleriyle birlikte listeler.
        Bu fonksiyon üst yönetimin hızlıca anlayabileceği bir özet sunar.
        """
        summary = {
            "critical_findings": [],
            "high_priority_issues": [],
            "notable_patterns": [],
            "positive_aspects": []
        }
        
        # Kritik bulguları analiz et
        for module_name, module_results in results.get("modules", {}).items():
            if isinstance(module_results, dict):
                # Kritik güvenlik açıklarını bul
                if "vulnerabilities" in module_results:
                    for vuln in module_results["vulnerabilities"]:
                        if vuln.get("risk_level", "").lower() == "critical":
                            summary["critical_findings"].append({
                                "title": vuln.get("title", "Unnamed Vulnerability"),
                                "impact": vuln.get("impact", "Unknown impact"),
                                "module": module_name,
                                "recommended_action": vuln.get("recommendation", "No specific recommendation")
                            })

                # Yüksek öncelikli sorunları belirle
                if "findings" in module_results:
                    for finding in module_results["findings"]:
                        if finding.get("priority", "").lower() == "high":
                            summary["high_priority_issues"].append({
                                "issue": finding.get("description", "Unnamed Issue"),
                                "context": finding.get("context", "No context provided"),
                                "module": module_name
                            })

        # Desenleri ve olumlu yönleri analiz et
        self._analyze_patterns_and_positives(results, summary)
        
        return summary

    def _analyze_patterns_and_positives(self, results, summary):
        """
        Güvenlik değerlendirmesindeki desenleri ve olumlu yönleri analiz eder.
        Bu analiz, sistemdeki tekrar eden sorunları ve iyi uygulamaları belirler.
        """
        patterns = {}
        positives = set()
        
        def analyze_item(item):
            if isinstance(item, dict):
                # Desenleri topla
                if "type" in item and "description" in item:
                    pattern_key = f"{item['type']}:{item.get('category', 'general')}"
                    if pattern_key not in patterns:
                        patterns[pattern_key] = {
                            "count": 0,
                            "examples": []
                        }
                    patterns[pattern_key]["count"] += 1
                    if len(patterns[pattern_key]["examples"]) < 3:  # En fazla 3 örnek
                        patterns[pattern_key]["examples"].append(item["description"])

                # Olumlu yönleri topla
                if item.get("assessment", "").lower() == "positive":
                    positives.add(item.get("description", ""))

                for value in item.values():
                    if isinstance(value, (dict, list)):
                        analyze_item(value)
            elif isinstance(item, list):
                for i in item:
                    analyze_item(i)

        # Tüm sonuçları analiz et
        analyze_item(results)

        # Önemli desenleri ekle
        for pattern_key, pattern_data in patterns.items():
            if pattern_data["count"] >= 2:  # En az 2 kez tekrar eden desenler
                summary["notable_patterns"].append({
                    "pattern": pattern_key.split(":")[0],
                    "category": pattern_key.split(":")[1],
                    "occurrence_count": pattern_data["count"],
                    "examples": pattern_data["examples"]
                })

        # Olumlu yönleri ekle
        summary["positive_aspects"] = list(positives)

    def _create_risk_overview(self, results):
        """
        Genel risk değerlendirmesi oluşturur.
        Bu özet, güvenlik durumunun üst düzey bir görünümünü sunar.
        """
        return {
            "overall_risk_level": self.calculate_overall_risk(results),
            "risk_distribution": results.get("statistics", {}).get("risk_distribution", {}),
            "most_vulnerable_areas": self._identify_vulnerable_areas(results),
            "risk_trends": self._analyze_risk_trends(results),
            "comparative_analysis": self._create_comparative_analysis(results)
        }

    def _identify_vulnerable_areas(self, results):
        """
        En savunmasız alanları belirler ve puanlar.
        Her alan için risk skorunu ve etkisini hesaplar.
        """
        vulnerable_areas = {}
        
        def analyze_vulnerability(item, context=""):
            if isinstance(item, dict):
                if "risk_level" in item and "component" in item:
                    area = item["component"]
                    risk_score = self.risk_level_to_score(item["risk_level"])
                    
                    if area not in vulnerable_areas:
                        vulnerable_areas[area] = {
                            "total_score": 0,
                            "finding_count": 0,
                            "top_findings": []
                        }
                    
                    vulnerable_areas[area]["total_score"] += risk_score
                    vulnerable_areas[area]["finding_count"] += 1
                    
                    if risk_score >= 7:  # Yüksek riskli bulgular
                        finding_info = {
                            "description": item.get("description", "No description"),
                            "risk_level": item["risk_level"],
                            "context": context
                        }
                        vulnerable_areas[area]["top_findings"].append(finding_info)
                
                for key, value in item.items():
                    if isinstance(value, (dict, list)):
                        analyze_vulnerability(value, f"{context}/{key}" if context else key)
            elif isinstance(item, list):
                for i in item:
                    analyze_vulnerability(i, context)

        # Tüm sonuçları analiz et
        analyze_vulnerability(results)

        # Alanları risk skorlarına göre sırala
        sorted_areas = sorted(
            vulnerable_areas.items(),
            key=lambda x: x[1]["total_score"],
            reverse=True
        )

        return {
            area: data for area, data in sorted_areas[:5]  # En riskli 5 alan
        }

    def _analyze_risk_trends(self, results):
        """
        Risk trendlerini analiz eder ve zaman içindeki değişimleri belirler.
        Güvenlik durumunun nasıl evrildiğini gösterir.
        """
        trends = {
            "improving_areas": [],
            "worsening_areas": [],
            "stable_areas": [],
            "trend_factors": []
        }

        # Önceki değerlendirmelerle karşılaştır
        if "previous_assessments" in results:
            for area, current_data in results.get("modules", {}).items():
                previous_data = results["previous_assessments"].get(area, {})
                
                if previous_data:
                    current_risk = self.calculate_area_risk(current_data)
                    previous_risk = self.calculate_area_risk(previous_data)
                    
                    change = current_risk - previous_risk
                    trend_info = {
                        "area": area,
                        "change": change,
                        "current_risk": current_risk,
                        "previous_risk": previous_risk,
                        "factors": self._identify_trend_factors(current_data, previous_data)
                    }
                    
                    if change < -1:  # İyileşme
                        trends["improving_areas"].append(trend_info)
                    elif change > 1:  # Kötüleşme
                        trends["worsening_areas"].append(trend_info)
                    else:  # Stabil
                        trends["stable_areas"].append(trend_info)

        return trends

    def _create_comparative_analysis(self, results):
        """
        Endüstri standartları ve benzer sistemlerle karşılaştırmalı analiz yapar.
        Bu analiz, güvenlik durumunun göreceli konumunu belirler.
        """
        return {
            "industry_comparison": self._compare_with_industry_standards(results),
            "peer_comparison": self._compare_with_peer_systems(results),
            "benchmark_metrics": self._calculate_benchmark_metrics(results)
        }

    def _compare_with_industry_standards(self, results):
        """
        Sonuçları endüstri standartlarıyla karşılaştırır.
        OWASP Mobile Top 10 ve CWE gibi standartları referans alır.
        """
        standards_comparison = {
            "owasp_mobile_top_10": self._analyze_owasp_compliance(results),
            "common_weaknesses": self._analyze_cwe_coverage(results),
            "compliance_status": self._analyze_compliance_status(results)
        }
        
        return standards_comparison

    def _analyze_owasp_compliance(self, results):
        """
        OWASP Mobile Top 10 uyumluluğunu analiz eder.
        Her kategori için uyumluluk seviyesini hesaplar.
        """
        owasp_categories = {
            "M1": "Improper Platform Usage",
            "M2": "Insecure Data Storage",
            "M3": "Insecure Communication",
            "M4": "Insecure Authentication",
            "M5": "Insufficient Cryptography",
            "M6": "Insecure Authorization",
            "M7": "Client Code Quality",
            "M8": "Code Tampering",
            "M9": "Reverse Engineering",
            "M10": "Extraneous Functionality"
        }
        
        compliance_analysis = {}
        
        for category, description in owasp_categories.items():
            # Her kategori için uyumluluk analizi yap
            findings = self._find_category_issues(results, category, description)
            
            compliance_analysis[category] = {
                "category_name": description,
                "findings_count": len(findings),
                "compliance_level": self._calculate_compliance_level(findings),
                "key_issues": [f["description"] for f in findings[:3]],  # En önemli 3 sorun
                "recommendations": self._generate_category_recommendations(findings)
            }
        
        return compliance_analysis

    def _find_category_issues(self, results, category, description):
        """
        Belirli bir OWASP kategorisine ait sorunları bulur.
        Metin analizi ve kategori eşleştirmesi yapar.
        """
        category_findings = []
        
        def search_issues(item):
            if isinstance(item, dict):
                # Kategori etiketlerini kontrol et
                if item.get("owasp_category") == category:
                    category_findings.append(item)
                # Açıklama içinde arama yap
                elif any(keyword in str(item).lower() for keyword in description.lower().split()):
                    if "description" in item:
                        category_findings.append(item)
                
                for value in item.values():
                    if isinstance(value, (dict, list)):
                        search_issues(value)
            elif isinstance(item, list):
                for i in item:
                    search_issues(i)
        
        search_issues(results)
        return category_findings

    def _calculate_compliance_level(self, findings):
        """
        Bulgulara göre uyumluluk seviyesini hesaplar.
        Risk seviyeleri ve bulgu sayısını dikkate alır.
        """
        if not findings:
            return {
                "level": "High",
                "score": 95,
                "description": "No significant issues found"
            }
        
        # Risk seviyelerine göre puan düşür
        base_score = 100
        deductions = {
            "critical": 20,
            "high": 15,
            "medium": 10,
            "low": 5
        }
        
        for finding in findings:
            risk_level = finding.get("risk_level", "low").lower()
            base_score -= deductions.get(risk_level, 0)
        
        # Puanı 0-100 aralığında tut
        final_score = max(0, min(100, base_score))
        
        # Seviye belirleme
        if final_score >= 90:
            level = "High"
            description = "Excellent compliance with few minor issues"
        elif final_score >= 75:
            level = "Medium-High"
            description = "Good compliance with some areas for improvement"
        elif final_score >= 60:
            level = "Medium"
            description = "Moderate compliance with significant improvements needed"
        else:
            level = "Low"
            description = "Poor compliance with critical improvements required"
        
        return {
            "level": level,
            "score": final_score,
            "description": description
        }

    def _generate_category_recommendations(self, findings):
        """
        Kategori bazlı öneriler oluşturur.
        Bulguların özelliklerine göre özel öneriler sunar.
        """
        recommendations = []
        
        # Risk seviyelerine göre önerileri grupla
        risk_groups = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": []
        }
        
        for finding in findings:
            risk_level = finding.get("risk_level", "low").lower()
            if risk_level in risk_groups:
                risk_groups[risk_level].append(finding)
        
        # Kritik ve yüksek riskli bulgular için detaylı öneriler
        for risk_level in ["critical", "high"]:
            for finding in risk_groups[risk_level]:
                recommendations.append({
                    "priority": "Immediate",
                    "finding": finding.get("description", ""),
                    "action": finding.get("recommendation", ""),
                    "estimated_effort": self._estimate_remediation_effort(finding)
                })
        
        # Orta ve düşük riskli bulgular için genel öneriler
        if risk_groups["medium"] or risk_groups["low"]:
            recommendations.append({
                "priority": "Planned",
                "finding": "Multiple medium/low risk issues",
                "action": "Implement security best practices and regular reviews",
                "estimated_effort": "Medium"
            })
        
        return recommendations

    def _estimate_remediation_effort(self, finding):
        """
        Bir bulgunun düzeltilmesi için gereken çabayı tahmin eder.
        Bulgunun karmaşıklığı ve etki alanına göre değerlendirme yapar.
        """
        effort_indicators = {
            "high": ["architecture", "redesign", "major    def generate_recommendations(self, results):
        """
        Analiz sonuçlarına göre öneriler oluşturur.
        Her risk seviyesi için özel öneriler ve eylem planları oluşturulur.
        """
        recommendations = {
            "immediate_actions": [],
            "short_term": [],
            "long_term": [],
            "best_practices": []
        }
        
        def extract_recommendations(item, category="best_practices"):
            if isinstance(item, dict):
                for key, value in item.items():
                    if "recommendation" in key.lower() or "solution" in key.lower():
                        if isinstance(value, str):
                            recommendations[category].append(value)
                        elif isinstance(value, list):
                            recommendations[category].extend(value)
                    elif isinstance(value, (dict, list)):
                        extract_recommendations(value, category)
            elif isinstance(item, list):
                for i in item:
                    extract_recommendations(i, category)
        
        # Sonuçları analiz et ve önerileri kategorize et
        for key, value in results.items():
            if isinstance(value, dict) and "risk_level" in value:
                if value["risk_level"].lower() in ["critical", "high"]:
                    extract_recommendations(value, "immediate_actions")
                elif value["risk_level"].lower() == "medium":
                    extract_recommendations(value, "short_term")
                else:
                    extract_recommendations(value, "long_term")
            elif isinstance(value, (dict, list)):
                extract_recommendations(value)
        
        return recommendations

    def analyze_malware_sample(self, sample_data):
        """
        Mobil malware örneğinin detaylı analizini gerçekleştirir.
        Static ve dinamik analiz tekniklerini kullanır.
        """
        try:
            # Malware analiz zincirini çalıştır
            analysis_result = self.malware_chain.run(sample_data)
            
            # Sonuçları parse et
            parsed_result = self.parse_results(analysis_result)
            
            # Tehdit seviyesini belirle
            threat_level = self.determine_threat_level(parsed_result)
            
            # IOC'leri (Compromise Göstergeleri) çıkar
            iocs = self.extract_iocs(parsed_result)
            
            return {
                "analysis_result": parsed_result,
                "threat_level": threat_level,
                "iocs": iocs,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                "error": f"Malware analizi sırasında hata: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }

    def determine_threat_level(self, analysis_result):
        """
        Malware analiz sonuçlarına göre tehdit seviyesini belirler.
        Çeşitli faktörleri değerlendirerek bir risk skoru hesaplar.
        """
        threat_indicators = {
            "high": [
                "root", "jailbreak", "banking", "ransomware", "keylogger",
                "remote_access", "data_exfiltration"
            ],
            "medium": [
                "adware", "excessive_permissions", "suspicious_api",
                "encrypted_payload", "dynamic_code"
            ],
            "low": [
                "aggressive_ads", "minimal_permissions", "open_source"
            ]
        }
        
        result_str = json.dumps(analysis_result).lower()
        
        # Tehdit göstergelerini say
        threat_counts = {
            "high": sum(1 for ind in threat_indicators["high"] if ind in result_str),
            "medium": sum(1 for ind in threat_indicators["medium"] if ind in result_str),
            "low": sum(1 for ind in threat_indicators["low"] if ind in result_str)
        }
        
        # Tehdit seviyesini hesapla
        if threat_counts["high"] > 0:
            return "Critical"
        elif threat_counts["medium"] > 2:
            return "High"
        elif threat_counts["medium"] > 0 or threat_counts["low"] > 2:
            return "Medium"
        else:
            return "Low"

    def extract_iocs(self, analysis_result):
        """
        Analiz sonuçlarından IOC'leri (Compromise Göstergeleri) çıkarır.
        URLs, IP adresleri, dosya hashleri gibi göstergeleri toplar.
        """
        iocs = {
            "urls": [],
            "ips": [],
            "domains": [],
            "file_hashes": [],
            "package_names": [],
            "suspicious_patterns": []
        }
        
        def extract_from_item(item):
            if isinstance(item, dict):
                for key, value in item.items():
                    # URL ve domainleri bul
                    if isinstance(value, str):
                        if "http" in value.lower() or "https" in value.lower():
                            iocs["urls"].append(value)
                        elif "." in value and "/" not in value and " " not in value:
                            iocs["domains"].append(value)
                    
                    # Hash değerlerini bul
                    if "hash" in key.lower() and isinstance(value, str):
                        iocs["file_hashes"].append(value)
                    
                    # Paket isimlerini bul
                    if "package" in key.lower() and isinstance(value, str):
                        iocs["package_names"].append(value)
                    
                    if isinstance(value, (dict, list)):
                        extract_from_item(value)
            elif isinstance(item, list):
                for i in item:
                    extract_from_item(i)
        
        extract_from_item(analysis_result)
        return iocs

    def perform_forensic_analysis(self, device_data):
        """
        Mobil cihaz üzerinde detaylı forensik analiz gerçekleştirir.
        Dosya sistemi, bellek ve iletişim verilerini analiz eder.
        """
        try:
            # Forensik analiz zincirini çalıştır
            analysis_result = self.forensic_chain.run(device_data)
            
            # Sonuçları parse et
            parsed_result = self.parse_results(analysis_result)
            
            # Zaman çizelgesi oluştur
            timeline = self.create_timeline(parsed_result)
            
            # Önemli artifactları çıkar
            artifacts = self.extract_artifacts(parsed_result)
            
            return {
                "analysis_result": parsed_result,
                "timeline": timeline,
                "artifacts": artifacts,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                "error": f"Forensik analiz sırasında hata: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }

    def create_timeline(self, forensic_result):
        """
        Forensik analiz sonuçlarından detaylı bir zaman çizelgesi oluşturur.
        Önemli olayları kronolojik sırayla düzenler.
        """
        timeline_events = []
        
        def extract_events(item, context=""):
            if isinstance(item, dict):
                for key, value in item.items():
                    if "time" in key.lower() or "date" in key.lower():
                        if isinstance(value, str):
                            try:
                                event_time = datetime.fromisoformat(value)
                                timeline_events.append({
                                    "timestamp": event_time,
                                    "context": context,
                                    "event": key,
                                    "details": value
                                })
                            except ValueError:
                                pass
                    elif isinstance(value, (dict, list)):
                        extract_events(value, context + "/" + key if context else key)
            elif isinstance(item, list):
                for i in item:
                    extract_events(i, context)
        
        extract_events(forensic_result)
        
        # Olayları zamana göre sırala
        timeline_events.sort(key=lambda x: x["timestamp"])
        
        return timeline_events

    def extract_artifacts(self, forensic_result):
        """
        Forensik analiz sonuçlarından önemli artifactları çıkarır.
        Dosyalar, loglar, iletişim verileri gibi önemli bulguları toplar.
        """
        artifacts = {
            "files": [],
            "logs": [],
            "communications": [],
            "credentials": [],
            "applications": [],
            "system_data": []
        }
        
        def categorize_artifact(item, category, artifact):
            if category not in artifacts:
                artifacts[category] = []
            if artifact not in artifacts[category]:
                artifacts[category].append(artifact)
        
        def extract_from_item(item, context=""):
            if isinstance(item, dict):
                for key, value in item.items():
                    # Dosya artifactları
                    if "file" in key.lower():
                        categorize_artifact("files", "files", {
                            "name": value if isinstance(value, str) else key,
                            "context": context,
                            "type": "file"
                        })
                    
                    # Log artifactları
                    if "log" in key.lower():
                        categorize_artifact("logs", "logs", {
                            "name": value if isinstance(value, str) else key,
                            "context": context,
                            "type": "log"
                        })
                    
                    # İletişim artifactları
                    if any(comm in key.lower() for comm in ["sms", "call", "message", "email"]):
                        categorize_artifact("communications", "communications", {
                            "name": value if isinstance(value, str) else key,
                            "context": context,
                            "type": "communication"
                        })
                    
                    if isinstance(value, (dict, list)):
                        extract_from_item(value, context + "/" + key if context else key)
            elif isinstance(item, list):
                for i in item:
                    extract_from_item(i, context)
        
        extract_from_item(forensic_result)
        return artifacts

    def run_full_security_assessment(self, target_info):
        """
        Hedef mobil cihaz veya uygulama için tam kapsamlı güvenlik değerlendirmesi yapar.
        Tüm analiz modüllerini sırayla çalıştırır.
        """
        assessment_results = {
            "target_info": target_info,
            "start_time": datetime.now().isoformat(),
            "modules": {}
        }
        
        try:
            # OWASP analizi
            assessment_results["modules"]["owasp"] = self.chain.run({
                "input": f"OWASP Mobile Top 10 analizi gerçekleştir: {target_info}"
            })
            
            # Malware taraması
            assessment_results["modules"]["malware"] = self.analyze_malware_sample(target_info)
            
            # Forensik analiz
            assessment_results["modules"]["forensic"] = self.perform_forensic_analysis(target_info)
            
            # Exploit kontrolü
            assessment_results["modules"]["exploit"] = self.chain.run({
                "input": f"Güvenlik açığı exploit analizi: {target_info}"
            })
            
            # Sonuçları birleştir ve özetle
            assessment_results["summary"] = self.generate_assessment_summary(assessment_results)
            assessment_results["recommendations"] = self.generate_recommendations(assessment_results)
            
        except Exception as e:
            assessment_results["error"] = str(e)
        finally:
            assessment_results["end_time"] = datetime.now().isoformat()
        
        return assessment_results

    def generate_assessment_summary(self, assessment_results):
        """
        Tüm değerlendirme sonuçlarını özetler ve genel bir risk profili oluşturur.
        """
        summary = {
            "risk_profile": self.calculate_overall_risk(assessment_results),
            "key_findings": self.extract_key_findings(assessment_results),
            "affected_components": self.identify_affected_components(assessment_results),
            "statistics": self.calculate_assessment_statistics(assessment_results)
        }
        
        return summary

    def calculate_overall_risk(self, results):
        """
        Tüm analiz sonuçlarını değerlendirerek genel risk seviyesini belirler.
        """
        risk_scores = []
        
        # Her modülden risk skorlarını topla
        for module_name, module_results in results["modules"].items():
            if isinstance(module_results, dict):
                if "threat_level" in module_results:
                    risk_scores.append(self.risk_level_to_score(module_results["threat_level"]))
                if "risk_level" in module_results:
                    risk_scores.append(self.risk_level_to_score(module_results["risk_level"]))
        
        if not risk_scores:
            return "Unknown"
        
        # Ortalama risk skorunu hesapla
        average_score = sum(risk_scores) / len(risk_scores)
        
        # Skoru risk seviyesine dönüştür
        if average_score >= 8:
            return "Critical"
        elif average_score >= 6:
            return "High"
        elif average_score >= 4:
            return "Medium"
        else:
            return "Low"

    def risk_level_to_score(self, level):
        """
        Risk seviyesini sayısal skora dönüştürür
        """
        risk_scores = {
            "critical": 10,
            "high": 7,
            "medium": 4,
            "low": 1
        }
        return risk_scores.get(level.lower(), 0)

    def extract_key_findings(self, results):
        """
        Tüm değerlendirmelerden önemli bulguları çıkarır
        """
        key_findings = []
        
        for module_name, module_results in results["modules"].items():
            if isinstance(module_results, dict):
                # OWASP bulguları
                if "vulnerabilities" in module_results:
                    for vuln in module_results["vulnerabilities"]:
                        if self.risk_level_to_score(vuln.get("risk_level", "low")) >= 4:
                            key_findings.append({
                                "type": "vulnerability",
                                "module": module_name,
                                "details": vuln
                            })
                
                # Malware bulguları
                if "iocs" in module_results:
                    for ioc_type, iocs in module_results["iocs"].items():
                        if iocs:  # Boş olmayan IOC'ler
                            key_findings.append({
                                "type": "indicator_of_compromise",
                                "module": module_name,
                                "ioc_type": ioc_type,
                                "count": len(iocs)
                            })
                
                # Forensik bulgular
                if "artifacts" in module_results:
                    for artifact_type, artifacts in module_results["artifacts"].items():
                        if artifacts:  # Önemli artifactlar
                            key_findings.append({
                                "type": "forensic_artifact",
                                "module": module_name,
                                "artifact_type": artifact_type,
                                "count": len(artifacts)
                            })
        
        return key_findings

    def identify_affected_components(self, results):
        """
        Güvenlik sorunlarından etkilenen sistem bileşenlerini belirler
        """
        affected_components = {
            "system": set(),
            "applications": set(),
            "network_services": set(),
            "data_storage": set(),
            "communication": set()
        }
        
        def analyze_component(item, context=""):
            if isinstance(item, dict):
                # Sistem bileşenleri
                if "system" in str(item).lower():
                    affected_components["system"].add(context)
                
                # Uygulama bileşenleri
                if "app" in str(item).lower() or "application" in str(item).lower():
                    affected_components["applications"].add(context)
                
                # Ağ servisleri
                if "network" in str(item).lower() or "service" in str(item).lower():
                    affected_components["network_services"].add(context)
                
                # Veri depolama
                if "storage" in str(item).lower() or "data" in str(item).lower():
                    affected_components["data_storage"].add(context)
                
                # İletişim bileşenleri
                if "communication" in str(item).lower() or "message" in str(item).lower():
                    affected_components["communication"].add(context)
                
                for key, value in item.items():
                    if isinstance(value, (dict, list)):
                        analyze_component(value, f"{context}/{key}" if context else key)
            elif isinstance(item, list):
                for i in item:
                    analyze_component(i, context)
        
        for module_results in results["modules"].values():
            analyze_component(module_results)
        
        # Set'leri liste formatına dönüştür
        return {k: list(v) for k, v in affected_components.items() if v}

    def calculate_assessment_statistics(self, results):
        """
        Güvenlik değerlendirmesi için istatistiksel analiz yapar
        """
        stats = {
            "total_findings": 0,
            "risk_distribution": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0
            },
            "module_statistics": {},
            "temporal_analysis": {
                "first_finding": None,
                "last_finding": None,
                "assessment_duration": None
            }
        }
        
        # Modül bazlı istatistikler
        for module_name, module_results in results["modules"].items():
            stats["module_statistics"][module_name] = {
                "finding_count": 0,
                "unique_components": set(),
                "risk_levels": {
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0
                }
            }
            
            if isinstance(module_results, dict):
                self._analyze_module_statistics(
                    module_results,
                    stats["module_statistics"][module_name],
                    stats["risk_distribution"]
                )
        
        # Toplam bulgu sayısını hesapla
        stats["total_findings"] = sum(
            module_stats["finding_count"]
            for module_stats in stats["module_statistics"].values()
        )
        
        # Zamansal analiz
        if "start_time" in results and "end_time" in results:
            start_time = datetime.fromisoformat(results["start_time"])
            end_time = datetime.fromisoformat(results["end_time"])
            stats["temporal_analysis"]["assessment_duration"] = str(end_time - start_time)
        
        return stats

    def _analyze_module_statistics(self, module_results, module_stats, risk_distribution):
        """
        Tek bir modül için istatistiksel analiz yapar
        """
        def process_item(item):
            if isinstance(item, dict):
                # Risk seviyesi sayımı
                if "risk_level" in item:
                    level = item["risk_level"].lower()
                    if level in module_stats["risk_levels"]:
                        module_stats["risk_levels"][level] += 1
                        risk_distribution[level] += 1
                
                # Etkilenen bileşen analizi
                if "component" in item:
                    module_stats["unique_components"].add(item["component"])
                
                # Bulgu sayımı
                if any(key in item for key in ["finding", "vulnerability", "artifact", "ioc"]):
                    module_stats["finding_count"] += 1
                
                for value in item.values():
                    if isinstance(value, (dict, list)):
                        process_item(value)
            elif isinstance(item, list):
                for i in item:
                    process_item(i)
        
        process_item(module_results)
        module_stats["unique_components"] = list(module_stats["unique_components"])

    def generate_final_report(self, assessment_results):
        """
        Tüm güvenlik değerlendirmesini kapsamlı bir rapora dönüştürür
        """
        report = {
            "executive_summary": self._create_executive_summary(assessment_results),
            "technical_findings": self._organize_technical_findings(assessment_results),
            "risk_assessment": self._create_risk_assessment(assessment_results),
            "recommendations": self._create_detailed_recommendations(assessment_results),
            "appendices": self._create_appendices(assessment_results)
        }
        
        return report

    def _create_executive_summary(self, results):
        """
        Üst yönetim için özet rapor oluşturur
        """
        summary = {
            "overview": {
                "assessment_date": results.get("start_time"),
                "duration": results.get("temporal_analysis", {}).get("assessment_duration"),
                "scope": self._determine_assessment_scope(results)
            },
            "key_findings": self._summarize_key_findings(results),
            "risk_overview": self._create_risk_overview(results),
            "immediate_actions": self._identify_immediate_actions(results)
        }
        
        return summary

    def _determine_assessment_scope(self, results):
        """
        Değerlendirmenin kapsamını belirler
        """
        scope = {
            "platforms": set(),
            "assessment_types": set(),
            "components": set()
        }
        
        def analyze_scope(item):
            if isinstance(item, dict):
                # Platform analizi
                if "platform" in item:
                    scope["platforms"].add(item["platform"])
                
                # Değerlendirme türü analizi
                if "assessment_type" in item:
                    scope["assessment_types"].add(item["assessment_type"])
                
                # Bileşen analizi
                if "component" in item:
                    scope["components"].add(item["component"])
                
                for value in item.values():
                    if isinstance(value, (dict, list)):
                        analyze_scope(value)
            elif isinstance(item, list):
                for i in item:
                    analyze_scope(i)
        
        analyze_scope(results)
        return {k: list(v) for k, v in scope.items() if v}

def main():
    """
    Framework'ün ana çalıştırma fonksiyonu
    """
    try:
        # Framework'ü başlat
        framework = AdvancedMobilePentestFramework("your-api-key")
        
        # Test hedefini tanımla
        target_info = {
            "platform": "Android",
            "os_version": "11.0",
            "device_model": "Samsung Galaxy S21",
            "apps": ["com.example.banking", "com.example.wallet"],
            "assessment_scope": ["malware", "forensic", "network"]
        }
        
        # Tam güvenlik değerlendirmesini çalıştır
        results = framework.run_full_security_assessment(target_info)
        
        # Sonuçları raporla
        report = framework.generate_final_report(results)
        
        # Raporu JSON formatında kaydet
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f"security_assessment_report_{timestamp}.json"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=4, ensure_ascii=False)
        
        print(f"\nGüvenlik değerlendirmesi tamamlandı. Rapor kaydedildi: {report_file}")
        
    except Exception as e:
        print(f"Hata oluştu: {str(e)}")

if __name__ == "__main__":
    main()from langchain.chains import LLMChain, SequentialChain
from langchain.chains.router import MultiPromptChain
from langchain.chains.router.llm_router import LLMRouterChain, RouterOutputParser
from langchain_groq import ChatGroq
from langchain.prompts import PromptTemplate, ChatPromptTemplate
from langchain.memory import ConversationBufferMemory
import json
from datetime import datetime
import hashlib
import base64

class AdvancedMobilePentestFramework:
    """
    Gelişmiş Mobil Güvenlik Test Framework'ü
    Bu framework dört ana özelliği birleştirir:
    1. Otomatik Exploit Geliştirme
    2. OWASP Mobile Top 10 Analizi
    3. Mobil Malware Analizi
    4. Forensik Analiz
    """
    
    def __init__(self, api_key):
        self.llm = ChatGroq(api_key=api_key, temperature=0.7)
        self.setup_memories()
        self.setup_chains()
        self.session_data = {}

    def setup_memories(self):
        """Her özellik için ayrı bellek alanları oluştur"""
        self.memories = {
            "exploit": ConversationBufferMemory(input_key="scenario", output_key="exploit"),
            "owasp": ConversationBufferMemory(input_key="app_info", output_key="vulnerabilities"),
            "malware": ConversationBufferMemory(input_key="sample", output_key="analysis"),
            "forensic": ConversationBufferMemory(input_key="device_data", output_key="findings")
        }

    def setup_chains(self):
        """Tüm özelleştirilmiş zincirleri hazırla"""
        
        # 1. Otomatik Exploit Geliştirme Zinciri
        exploit_template = """
        Bu mobil güvenlik açığı için güvenli bir PoC (Proof of Concept) exploit geliştir:
        {scenario}

        Lütfen aşağıdaki yapıyı kullan:
        1. Zafiyet Analizi
            - Etkilenen bileşen
            - Saldırı vektörü
            - CVSS skoru
        
        2. Exploit Detayları
            - Gerekli koşullar
            - Teknik adımlar
            - Başarı kriterleri
        
        3. Güvenlik Önlemleri
            - Test ortamı gereksinimleri
            - Risk azaltma adımları
            - Yasal uyarılar

        4. Kod Şablonu
            - Pseudo kod
            - Test senaryoları
            - Doğrulama adımları

        JSON formatında döndür.
        """

        self.exploit_chain = LLMChain(
            llm=self.llm,
            prompt=PromptTemplate(
                input_variables=["scenario"],
                template=exploit_template
            ),
            memory=self.memories["exploit"],
            verbose=True
        )

        # 2. OWASP Mobile Top 10 Analiz Zinciri
        owasp_template = """
        Bu mobil uygulamayı OWASP Mobile Top 10 kriterlerine göre analiz et:
        {app_info}

        Her kategori için analiz yap:
        1. M1: Uygunsuz Platform Kullanımı
        2. M2: Güvensiz Veri Depolama
        3. M3: Güvensiz İletişim
        4. M4: Güvensiz Kimlik Doğrulama
        5. M5: Yetersiz Kriptografi
        6. M6: Güvensiz Yetkilendirme
        7. M7: İstemci Kodu Kalitesi
        8. M8: Kod Tampering
        9. M9: Ters Mühendislik
        10. M10: Fazladan İşlevsellik

        Her kategori için:
        - Risk seviyesi
        - Bulunan zafiyetler
        - Düzeltme önerileri
        - Test senaryoları

        JSON formatında döndür.
        """

        self.owasp_chain = LLMChain(
            llm=self.llm,
            prompt=PromptTemplate(
                input_variables=["app_info"],
                template=owasp_template
            ),
            memory=self.memories["owasp"],
            verbose=True
        )

        # 3. Mobil Malware Analiz Zinciri
        malware_template = """
        Bu mobil malware örneğini analiz et:
        {sample}

        Analiz alanları:
        1. Statik Analiz
            - Paket bilgileri
            - İzinler
            - Manifest analizi
            - Kod imzaları
        
        2. Dinamik Analiz
            - Ağ aktivitesi
            - API çağrıları
            - Dosya sistemi değişiklikleri
            - Davranış analizi
        
        3. Tehdit Analizi
            - Malware türü
            - Yetenekleri
            - Hedef sistemler
            - Yayılma mekanizması
        
        4. Önlemler
            - Tespit yöntemleri
            - Koruma mekanizmaları
            - Temizleme prosedürleri

        JSON formatında döndür.
        """

        self.malware_chain = LLMChain(
            llm=self.llm,
            prompt=PromptTemplate(
                input_variables=["sample"],
                template=malware_template
            ),
            memory=self.memories["malware"],
            verbose=True
        )

        # 4. Forensik Analiz Zinciri
        forensic_template = """
        Bu mobil cihaz için forensik analiz gerçekleştir:
        {device_data}

        Analiz alanları:
        1. Dosya Sistemi Analizi
            - Silinmiş dosyalar
            - Sistem logları
            - Uygulama verileri
            - Medya dosyaları
        
        2. Bellek Analizi
            - RAM dökümü
            - Geçici dosyalar
            - Şifreli veriler
            - Çalışan işlemler
        
        3. İletişim Analizi
            - SMS/MMS
            - Arama kayıtları
            - E-posta
            - Mesajlaşma uygulamaları
        
        4. Uygulama Analizi
            - Yüklenmiş uygulamalar
            - Uygulama geçmişi
            - Cache verileri
            - Kimlik bilgileri

        5. Zaman Çizelgesi
            - Önemli olaylar
            - Dosya değişiklikleri
            - Kullanıcı aktivitesi
            - Sistem olayları

        JSON formatında döndür.
        """

        self.forensic_chain = LLMChain(
            llm=self.llm,
            prompt=PromptTemplate(
                input_variables=["device_data"],
                template=forensic_template
            ),
            memory=self.memories["forensic"],
            verbose=True
        )

        # Router yapılandırması
        router_template = """
        Verilen mobil güvenlik analiz talebini en uygun kategoriye yönlendir.
        
        Analiz talebi: {input}
        
        Kategoriler:
        1. exploit (Güvenlik açığı exploit geliştirme)
        2. owasp (OWASP Mobile Top 10 analizi)
        3. malware (Kötücül yazılım analizi)
        4. forensic (Adli analiz)

        Sadece kategori ismini döndür: exploit, owasp, malware, veya forensic
        """

        self.router_chain = LLMRouterChain.from_llm(
            self.llm,
            router_template,
            RouterOutputParser()
        )

        # Multi-prompt zinciri oluştur
        self.chain = MultiPromptChain(
            router_chain=self.router_chain,
            destination_chains={
                "exploit": self.exploit_chain,
                "owasp": self.owasp_chain,
                "malware": self.malware_chain,
                "forensic": self.forensic_chain
            },
            default_chain=self.owasp_chain,
            verbose=True
        )

    def generate_report_id(self):
        """Benzersiz rapor ID'si oluştur"""
        timestamp = datetime.now().isoformat()
        return hashlib.sha256(timestamp.encode()).hexdigest()[:12]

    def run_analysis(self, input_data):
        """Tam güvenlik analizini çalıştır"""
        report_id = self.generate_report_id()
        self.session_data[report_id] = {
            "start_time": datetime.now(),
            "input_data": input_data,
            "status": "running"
        }

        try:
            # Ana analizi çalıştır
            result = self.chain.run(input_data)
            
            # Sonuçları parse et
            parsed_result = self.parse_results(result)
            
            # Detaylı rapor oluştur
            report = self.generate_detailed_report(parsed_result, report_id)
            
            self.session_data[report_id].update({
                "status": "completed",
                "end_time": datetime.now(),
                "results": parsed_result,
                "report": report
            })
            
            return report
            
        except Exception as e:
            self.session_data[report_id].update({
                "status": "failed",
                "end_time": datetime.now(),
                "error": str(e)
            })
            raise

    def parse_results(self, results):
        """Analiz sonuçlarını parse et"""
        try:
            if isinstance(results, str):
                return json.loads(results)
            return results
        except json.JSONDecodeError:
            return {"raw_output": results}

    def generate_detailed_report(self, results, report_id):
        """Detaylı güvenlik raporu oluştur"""
        session = self.session_data[report_id]
        
        return {
            "report_id": report_id,
            "timestamp": datetime.now().isoformat(),
            "analysis_duration": str(datetime.now() - session["start_time"]),
            "summary": {
                "title": "Mobil Güvenlik Analiz Raporu",
                "scope": self.determine_analysis_scope(results),
                "risk_level": self.calculate_risk_level(results),
                "findings_count": self.count_findings(results)
            },
            "detailed_findings": results,
            "recommendations": self.generate_recommendations(results),
            "metadata": {
                "framework_version": "2.0.0",
                "analysis_modules": list(self.chain.destination_chains.keys())
            }
        }

    def determine_analysis_scope(self, results):
        """Analiz kapsamını belirle"""
        scope_indicators = {
            "exploit": ["vulnerability", "exploit", "poc"],
            "owasp": ["authentication", "cryptography", "authorization"],
            "malware": ["malicious", "trojan", "spyware"],
            "forensic": ["filesystem", "memory", "communication"]
        }
        
        detected_scopes = []
        results_str = json.dumps(results).lower()
        
        for scope, indicators in scope_indicators.items():
            if any(ind in results_str for ind in indicators):
                detected_scopes.append(scope)
        
        return detected_scopes

    def calculate_risk_level(self, results):
        """Genel risk seviyesini hesapla"""
        risk_scores = {
            "critical": 4,
            "high": 3,
            "medium": 2,
            "low": 1
        }
        
        total_score = 0
        count = 0
        
        def process_item(item):
            nonlocal total_score, count
            if isinstance(item, dict):
                for key, value in item.items():
                    if key in ["risk", "risk_level", "severity"]:
                        if value.lower() in risk_scores:
                            total_score += risk_scores[value.lower()]
                            count += 1
                    elif isinstance(value, (dict, list)):
                        extract_recommendations(value, category)
        
        # Sonuçları analiz et ve önerileri kategorize et
        for key, value in results.items():
            if isinstance(value, dict) and "risk_level" in value:
                if value["risk_level"].lower() in ["critical", "high"]:
                    extract_recommendations(value, "immediate_actions")
                elif value["risk_level"].lower() == "medium":
                    extract_recommendations(value, "short_term")
                else:
                    extract_recommendations(value, "long_term")
            elif isinstance(value, (dict, list)):
                extract_recommendations(value)
        
        return recommendations

def run_test_scenarios(self):
    """Test senaryolarını çalıştır"""
    scenarios = [
        # Exploit Geliştirme Senaryosu
        {
            "type": "exploit",
            "description": """
            Android uygulamasında deeplink işleme zafiyeti tespit edildi.
            Intent filtreleri doğru yapılandırılmamış ve arbitrary URL açılmasına
            izin veriyor. PoC exploit geliştirmemiz gerekiyor.
            """,
            "expected_output": ["vulnerability_analysis", "exploit_code", "mitigation"]
        },
        
        # OWASP Analiz Senaryosu
        {
            "type": "owasp",
            "description": """
            Yeni geliştirilen finans uygulamasının OWASP Mobile Top 10
            kriterlerine göre güvenlik değerlendirmesini yapın. Uygulama
            SSL pinning kullanıyor ve root detection içeriyor.
            """,
            "expected_output": ["m1_platform_usage", "m3_communication", "m5_cryptography"]
        },
        
        # Malware Analiz Senaryosu
        {
            "type": "malware",
            "description": """
            Kullanıcılar bir Android bankacılık trojanı tarafından hedef alınıyor.
            Malware WhatsApp üzerinden yayılıyor ve kendini meşru bir kripto
            cüzdan uygulaması olarak gösteriyor. APK dosyasını analiz edin.
            """,
            "expected_output": ["static_analysis", "dynamic_analysis", "threat_analysis"]
        },
        
        # Forensik Analiz Senaryosu
        {
            "type": "forensic",
            "description": """
            Şirket telefonunda veri sızıntısı şüphesi var. Son 30 günlük
            aktiviteyi analiz edin. Özellikle WhatsApp, e-posta ve dosya
            transfer aktivitelerine odaklanın.
            """,
            "expected_output": ["filesystem_analysis", "communication_analysis", "timeline"]
        }
    ]
    
    test_results = []
    for scenario in scenarios:
        try:
            print(f"\nTest Senaryosu: {scenario['type']}")
            result = self.run_analysis(scenario['description'])
            
            # Beklenen çıktıları kontrol et
            validation = self.validate_test_output(result, scenario['expected_output'])
            
            test_results.append({
                "scenario_type": scenario['type'],
                "status": "success" if validation['valid'] else "partial",
                "validation": validation,
                "result": result
            })
            
        except Exception as e:
            test_results.append({
                "scenario_type": scenario['type'],
                "status": "failed",
                "error": str(e)
            })
    
    return test_results

def validate_test_output(self, result, expected_outputs):
    """Test sonuçlarını doğrula"""
    validation = {
        "valid": True,
        "missing_outputs": [],
        "found_outputs": []
    }
    
    result_str = json.dumps(result).lower()
    
    for expected in expected_outputs:
        if expected.lower() in result_str:
            validation["found_outputs"].append(expected)
        else:
            validation["missing_outputs"].append(expected)
            validation["valid"] = False
    
    return validation

# Örnek kullanım
def main():
    """Ana test sürecini çalıştır"""
    try:
        framework = AdvancedMobilePentestFramework("your-api-key")
        
        print("Mobil Güvenlik Test Framework'ü Başlatıldı")
        print("\nTest Senaryoları Çalıştırılıyor...")
        
        results = framework.run_test_scenarios()
        
        print("\nTest Sonuçları:")
        for result in results:
            print(f"\nSenaryo: {result['scenario_type']}")
            print(f"Durum: {result['status']}")
            
            if result['status'] == "success":
                print("Validasyon:")
                print(f"- Bulunan çıktılar: {', '.join(result['validation']['found_outputs'])}")
            elif result['status'] == "partial":
                print("Eksik çıktılar:")
                print(f"- {', '.join(result['validation']['missing_outputs'])}")
            else:
                print(f"Hata: {result['error']}")
        
        print("\nDetaylı raporlar 'test_results' dizininde oluşturuldu.")
        
    except Exception as e:
        print(f"Framework başlatılırken hata oluştu: {str(e)}")

if __name__ == "__main__":
    main(), (dict, list)):
                        process_item(value)
            elif isinstance(item, list):
                for i in item:
                    process_item(i)
        
        process_item(results)
        
        if count == 0:
            return "Unknown"
            
        average_score = total_score / count
        
        if average_score >= 3.5:
            return "Critical"
        elif average_score >= 2.5:
            return "High"
        elif average_score >= 1.5:
            return "Medium"
        else:
            return "Low"

    def count_findings(self, results):
        """Bulguları kategorilere göre say"""
        counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
        
        def count_item(item):
            if isinstance(item, dict):
                for key, value in item.items():
                    if key in ["risk", "risk_level", "severity"]:
                        level = value.lower()
                        if level in counts:
                            counts[level] += 1
                    elif isinstance(value, (dict, list)):
                        count_item(value)
            elif isinstance(item, list):
                for i in item:
                    count_item(i)
        
        count_item(results)
        return counts

    def generate_recommendations(self, results):
        """Analiz sonuçlarına göre öneriler oluştur"""
        recommendations = {
            "immediate_actions": [],
            "short_term": [],
            "long_term": [],
            "best_practices": []
        }
        
        def extract_recommendations(item, category="best_practices"):
            if isinstance(item, dict):
                for key, value in item.items():
                    if "recommendation" in key.lower() or "solution" in key.lower():
                        if isinstance(value, str):
                            recommendations[category].append(value)
                        elif isinstance(value, list):
                            recommendations[category].extend(value)
                    elif isinstance(value, (dict, list)):
                        extract_recommendations(value, category)
            elif isinstance(item, list):
                for i in item:
                    extract_recommendations(i, category)
```





 LangChain aslında saldırıları kendisi yapmıyor - o bir çerçeve (framework) yani bir organizasyon aracı. Bunu günlük hayattan bir örnekle açıklayayım:

LangChain'i bir şef restoranındaki baş garsona benzetebiliriz. Baş garson yemekleri pişirmiyor (saldırıları yapmıyor), ancak:

- Müşterinin siparişini alıyor (bizim talimatlarımızı)
- Bu siparişi mutfağa iletiyor (LLM'e gönderiyor)
- Gelen yemekleri organize ediyor (sonuçları düzenliyor)
- Servis kalitesini kontrol ediyor (çıktıları yönetiyor)

LangChain bizim verdiğimiz talimatları (prompts) alıp:

1. Önce bunları organize ediyor
2. Groq gibi bir LLM'e gönderiyor
3. Gelen cevapları düzenliyor
4. Sonuçları bize sunuyor

Yani biz bir güvenlik açığı analizi istediğimizde:

- LangChain bu isteği düzenli bir formata sokuyor
- LLM'e gönderiyor
- LLM analizi yapıyor ve cevap veriyor
- LangChain bu cevabı alıp düzenli bir şekilde bize sunuyor